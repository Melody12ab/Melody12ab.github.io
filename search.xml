<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[压测总结]]></title>
    <url>%2F2019%2F08%2F26%2Faboout-bench%2F</url>
    <content type="text"><![CDATA[最近对线上TCP系统做了一次压测，借这次机会从流程和工具方面总结下这次压测。 压测流程1.搞清楚背景搞清楚为什么要进行压测，大背景是什么。清楚的理解背景之后才能帮助我们更好的去设计压测方案。 2.制定目标根据背景，制定可量化的目标，可以考虑从系统和业务两个方向去考虑，比如稳定在线数、QPS、CPU负载、GC等。大部分压测并不是冒烟测试，而是需要去探测当前业务量猛然增加比如N倍之后，系统是否可以稳定运行。因此一个清晰目标往往也告诉了我们当前次压测的重点和终点在哪里。 3.梳理系统流程在制定压测方案之前，需要我们对待压系统进行系统的梳理，根据目标，梳理待压系统的业务流程，数据流，线程模型等等。清晰的系统流程可以帮助我们有针对的设计压测方案，同时也可以帮助我们对压测问题进行定位优化。对系统不清楚的情况下，虽然可以做黑盒压测，但是很难去针对性的进行优化，而我们之所以进行压测，往往都伴随着优化任务，因此建议不管什么情况下，先建议梳理清楚系统。 4.制定压测方案很多时候有了对目标和系统清晰的认识，压测方案相对也就出来了，这里建议可以多设计几个方案，明确各方案优劣势，可以拉有经验的大佬讨论一下，充分考虑各种场景，相信这样出来的方案也会是一个经得起推敲和挑战的方案了。方案中需要包括但不限于：压测环境需求，系统参数调优，数据隔离方案，监控方案。 5.制定方案实施计划&amp;实施压测至此到了实操环境了，根据压测方案步骤，实施压测计划，可能包括了环境准备，参数调整，各种中间件环境隔离及系统压测环境改造等等，由于涉及到的事情比较杂，可以通过系统的方式将这些事情可视化的管理起来，方便进度追踪。 6.问题发现及解决压测的过程一般都伴随着问题的暴露，监控不完善，性能问题，限流告警等等，这个时候需要将这个问题都记录并管理起来，分好个问题优先级，制定跟踪人，解决时间，直至后续闭环解决。 7.结论产出及压测报告产出整理以上各个步骤产出，从背景，目标，方案，实施，问题，结论等方面系统全面呈现压测情况，报告需要逻辑清洗，有理有据，有说服力。 8.总结沉淀经过以上各个步骤后，产生的一些想法，总结做的好的，做的不好的点，规划接下来需要做的事情，沉淀方法论。 工具 JMeter：Apache组织开发的基于Java的压力测试工具，可用于测试静态和动态资源，也可以用于对服务器、网络或对象模拟巨大的负载，同时还能够对应用程序做功能/回归测试。 优点：简单方便，功能完善，开源。 缺点：问题排查不如自己写的测试工具方便。 Tsung：Tsung是erlang开发的一款开源多协议分布式负载并发测试工具，可用作HTTP、WebDAV、SOAP、PostgreSQL、MySQL、LDAP和Jabber/XMPP的服务器压力测试。 优点：功能强大，相对透明。 缺点：使用成本相较于JMeter更高。 自定义压测客户端：完全可控，高度灵活。 优点：灵活，可控。 缺点：开发设计成本高。]]></content>
      <categories>
        <category>压测</category>
      </categories>
      <tags>
        <tag>压测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java日期解析]]></title>
    <url>%2F2019%2F08%2F12%2FdateFormat%2F</url>
    <content type="text"><![CDATA[问题发现最近在做系统性能优化，发现系统中一处时间格式化方法耗时异常高。打开系统代码，翻看发现在codec中，处理上行时，每一个上行消息都会创建一个SimpleDateFormat对象，而SimpleDateFormat是一个线程不安全且性能有问题的一个类，业务代码以此来解析上报时间字符串。代码片段如下： 1234567String softTime = "190812122359";try &#123; DateFormat format = new SimpleDateFormat("yyMMddHHmmss"); Date date = format.parse(softTime);&#125; catch (ParseException e) &#123; //省略……&#125; 问题解决一开始由于对JDK 8提供的日期函数不熟悉，直接上了joda-time，由于joda的DateTimeFormatter创建层面进行了池化处理，增加如下方法，以修复重复创建的性能问题： 12345private static long parseDeviceTime(String softTime)&#123; DateTimeFormatter dfm = DateTimeFormat.forPattern("yyMMddHHmmss"); DateTime dateTime = dfm.parseDateTime(softTime); return dateTime.getMillis();&#125; 问题复现经过以上修改，问题得以解决，但又发现了新的问题：joda-time在parse时间字符串时，无法兼容60秒这种场景，如’2019-08-12 11:30:60’，遇到这类字符串joda会直接抛出异常，这就是一个比较坑的地方，明明可能抛出异常，但却没有在方法签名中声名，导致使用方未进行catch，进而中断主流程。同时测试发现JDK 8的时间API亦有相同问题。 问题解决重新考虑使用SimpleDateFormat，对于重复创建问题，使用共享同一实例解决，针对多线程问题，使用ThreadLocal。修改代码如下： 12345678910private static ThreadLocal&lt;SimpleDateFormat&gt; local = new ThreadLocal&lt;SimpleDateFormat&gt;() &#123; @Override protected SimpleDateFormat initialValue() &#123; return new SimpleDateFormat("yyMMddHHmmss"); &#125;&#125;; public static Date parse(String dateStr) throws Exception &#123; return local.get().parse(dateStr);&#125; 总结 SimpleDateFormat存在性能问题，且线程不安全，使用需谨慎。 SimpleDateFormat往JDK 8或joda迁移时，主要考虑兼容性，如老业务场景中是否存在代码时间为60s的场景等。 在写代码时，方法如果有没有handle的异常，需要在签名中声明，以防使用方使用不当。]]></content>
      <categories>
        <category>date</category>
      </categories>
      <tags>
        <tag>date</tag>
        <tag>SimpleDateFormat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西行纪]]></title>
    <url>%2F2019%2F08%2F07%2Fxixingji%2F</url>
    <content type="text"><![CDATA[这是一部看起来很过瘾的漫画，看过的少有的全彩漫画。 记得是看了一篇关于这部漫画的介绍，由于时间有点久了，里面吸引我的是“一个不一样的西游故事“，当时记得有点像是悟空传的剧情。 最后一看就停不下来了，颠覆了很多角色的认识，唐三藏，真实、潇洒、率性还很能打；白龙马-傲雪，胆小、暴戾，同时也有善良的一面；如来，观音是大帅哥，并且观音还有洁癖；沙悟净，外冷内热的法术师……。 故事的时间是我们知道的西游之后的故事，整体设定和剧情很别致，虽然以前了解过悟空传之类西游故事，不过真正看过后还是有很多乐趣。 印象比较深的有： 唐三藏居然开了一家妓院，嗯，很有意思。 当上古三清和天庭光与暗势力正面冲突的时候，道德天尊调停的方式是将，光一方的大妖悟空杀掉，以促成暂时的和平，道德的最高点是如此的谄媚。 牛魔王和牛小妹的故事。 整体是一部比较精彩的漫画，极好的打发时间的利器。]]></content>
      <categories>
        <category>打发时间</category>
      </categories>
      <tags>
        <tag>漫画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle系列(二)-使用Gradle构建项目]]></title>
    <url>%2F2019%2F04%2F13%2Fgradle-second-create-build%2F</url>
    <content type="text"><![CDATA[上一篇文章中简单介绍了一下Gradle，既然从扩展性、灵活性、性能方面都这么出色，那这次就动手尝试看看如何使用Gradle来构建项目。 Gradle安装安装可参见官方文档Gradle Installation，todo推荐使用gradlew来管理项目，用过的人都说好，后面会介绍下gradlew的最佳实践。本机环境如下图： 初始化项目123&gt; mkdir gradle_demo&gt; cd gradle_demo&gt; gradle init 如上图所示gradle可以支持cpp、grovvy、java、kotlin类型的项目构建，同时可以使用groovy和kotlin做为DSL，看起来还不错，看下初始化后的项目结构： 目前新版的Gradle在执行初始化时会自动将gradle wrapper plugin应用于项目。介绍下期中的几个文件： build.gradle：当前项目的构建脚本（类似于maven的pom.xml） gradle-wrapper.jar：gradle wrapper可执行jar包 gradle-wrapper.properties：gradle wapper配置文件 gradlew：gradle wrapper unix-base系统下的可执行脚本 gradlew.bat：gradle wrapper Windows系统下的可执行脚本 settings.gradle：当前项目的配置文件 gradle init还可以将pom.xml”翻译”为Gradle项目，使用-p pom.xml 创建任务Gradle提供了丰富的API给我们使用基于Groovy或者Kotlin的DSL来创建和配置tasks，一个项目工程包含了一系列的Task，每个Task完成一些基本的操作，最后完成我们整个项目的构建。 Gradle给我们提供了一个方便我们构建项目的基本Task类型库，这里试一试其中的Copy Task。创建一个src目录，在其中添加一个myCopyFile.txt文件（内容为Hello World!）,定义一个Copy任务如下： 123456789build.gradletask copy( type: Copy, group: "MyCopyGroup", description: "Copy File Task" ) &#123; from "src" into "dest"&#125; 执行Task，发现自动为我们创建了dest目录，并将myCopyFile.txt copy到了目标目录，Gradle正是通过这种强大的任务定义机制以及描述性丰富的DSL满足了我们各种定制需求，这点还是很不错的。（想想这个要在maven中实现麻烦多了） 123456789101112131415161718192021222324xiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; ./gradlew copy 19-04-13 22:27Downloading https://services.gradle.org/distributions/gradle-5.3.1-bin.zip...................................................................................BUILD SUCCESSFUL in 36s1 actionable task: 1 executedxiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; tree 19-04-13 22:28.├── build.gradle├── dest│ └── myCopyFile.txt├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew├── gradlew.bat├── settings.gradle└── src └── myCopyFile.txt4 directories, 8 filesxiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; cat dest/myCopyFile.txt 19-04-13 22:31Hello World! 应用插件插件可以理解为一系列task的集合，Gradle提供了很丰富的基础插件，另外还有很多第三方插件，其中base插件提供了大多数项目生命周期中都有的task。如下任务利用base插件和Zip打包我们的src目录： 123456789101112build.gradleplugins &#123; id "base"&#125;task zip( type: Zip, group: "Archive", description: "Archives src") &#123; from "src" setArchiveName "gradle-demo-1.0.zip"&#125; 执行zip任务 1234567891011121314151617181920212223xiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; ./gradlew zip 19-04-13 22:53BUILD SUCCESSFUL in 1s1 actionable task: 1 executedxiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; tree 19-04-13 22:53.├── build│ └── distributions│ └── gradle-demo-1.0.zip├── build.gradle├── dest│ └── myCopyFile.txt├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew├── gradlew.bat├── settings.gradle└── src └── myCopyFile.txt6 directories, 9 files 探索 &amp; build scan更多Gradle使用方法可以查看官方的CLI Interface，在项目中查询有哪些可用的task可使用gradlew task，会列出我们自己定义的任务以及plugin引入的任务。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152xiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; ./gradlew tasks 19-04-13 23:00&gt; Task :tasks------------------------------------------------------------Tasks runnable from root project------------------------------------------------------------Archive tasks-------------zip - Archives srcBuild tasks-----------assemble - Assembles the outputs of this project.build - Assembles and tests this project.clean - Deletes the build directory.Build Setup tasks-----------------init - Initializes a new Gradle build.wrapper - Generates Gradle wrapper files.Help tasks----------buildEnvironment - Displays all buildscript dependencies declared in root project 'gradle_demo'.components - Displays the components produced by root project 'gradle_demo'. [incubating]dependencies - Displays all dependencies declared in root project 'gradle_demo'.dependencyInsight - Displays the insight into a specific dependency in root project 'gradle_demo'.dependentComponents - Displays the dependent components of components in root project 'gradle_demo'. [incubating]help - Displays a help message.model - Displays the configuration model of root project 'gradle_demo'. [incubating]projects - Displays the sub-projects of root project 'gradle_demo'.properties - Displays the properties of root project 'gradle_demo'.tasks - Displays the tasks runnable from root project 'gradle_demo'.Verification tasks------------------check - Runs all checks.Rules-----Pattern: clean&lt;TaskName&gt;: Cleans the output files of a task.Pattern: build&lt;ConfigurationName&gt;: Assembles the artifacts of a configuration.Pattern: upload&lt;ConfigurationName&gt;: Assembles and uploads the artifacts belonging to a configuration.To see all tasks and more detail, run gradlew tasks --allTo see more detail about a task, run gradlew help --task &lt;task&gt;BUILD SUCCESSFUL in 0s1 actionable task: 1 executed 查询项目设置以及默认的属性信息可使用gradlew properties 123456789101112131415161718192021222324252627xiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; ./gradlew properties 19-04-13 23:04&gt; Task :properties------------------------------------------------------------Root project------------------------------------------------------------allprojects: [root project 'gradle_demo']ant: org.gradle.api.internal.project.DefaultAntBuilder@2a1a50e0antBuilderFactory: org.gradle.api.internal.project.DefaultAntBuilderFactory@4d2d5ed3archivesBaseName: gradle_demoartifacts: org.gradle.api.internal.artifacts.dsl.DefaultArtifactHandler_Decorated@46b8f540asDynamicObject: DynamicObject for root project 'gradle_demo'baseClassLoaderScope: org.gradle.api.internal.initialization.DefaultClassLoaderScope@35e7668dbuildDir: /Users/xiaobai/gradle_study/gradle_demo/buildbuildFile: /Users/xiaobai/gradle_study/gradle_demo/build.gradle……………………………… many propertiesstate: project state 'EXECUTED'status: integrationsubprojects: []tasks: task setversion: unspecifiedzip: task ':zip'BUILD SUCCESSFUL in 1s1 actionable task: 1 executed 还有一个特别值得提的功能是Gradle为我们提供了一个丰富的，基于Web的分析工具build scan，通过使用--scan的命令选项或在项目构建脚本中加入build scan插件，可以将我们的build scans结果发布到Gradle的服务上（也提供了企业级服务），并通一个生成的Web链接访问，这极大的方便了我们对构建过程的分析以及问题的排查。（对比当年maven构建除了问题，将整个错误日志贴出来问牛牛们，方便太多了） 1234567891011xiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; ./gradlew zip --scan 19-04-13 22:58BUILD SUCCESSFUL in 9s1 actionable task: 1 up-to-datePublishing a build scan to scans.gradle.com requires accepting the Gradle Terms of Service defined at https://gradle.com/terms-of-service. Do you accept these terms? [yes, no] yesGradle Terms of Service accepted.Publishing build scan...https://gradle.com/s/ohwhkuety36oc 访问以上生成的build scan链接：https://gradle.com/s/ohwhkuety36oc gradle wrapper官方推荐的使用Gradle进行项目构建的方式是使用Gradle Wrapper（后文简称Wrapper），Wrapper是一个使用我们声明的一个gradle版本（如果不存在就预先下载）进行项目构建的脚本，使开发者们可以在自己本地没有安装Gradle的情况下进行项目构建等操作。以下为Wrapper的工作流：好处： 统一构建项目的gradle的版本，避免版本不同导致的构建问题（gradle的版本相比maven非常多） 修改或升级gradle版本非常方便 为我们的项目添加Gradle Wrapper如上文中我使用的版本在执行初始化时，自动引入了Wrapper。但是当我们在使用老版本或需要为没有添加Wrapper的项目添加Wrapper时，可使用gradle wrapper为我们的项目添加Wrapper支持。生成的Wrapper文件如下： 1234567xiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; tree gradle 19-04-13 23:06gradle└── wrapper ├── gradle-wrapper.jar └── gradle-wrapper.properties1 directory, 2 files 在实际开发中，为了让Wrapper对其他开发者也有效，需要将这个目录添加到版本控制中。gradle-wrapper.properties文件中存放着Gradle的基本信息： 12345678distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/dists# 我们使用的Gradle远程地址以及版本distributionUrl=https\://services.gradle.org/distributions/gradle-5.3.1-bin.zipzipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/dists# 文件校验码distributionSha256Sum=371cb9fbebbe9880d147f59bab36d61eee122854ef8c9ee1ecf12b82368bcf10 所有以上的属性都可以通过生成Wrapper时通过指定一下参数来设置： 1234567--gradle-version：指定Gradle版本 --distribution-type：指定Gradle distribution的类型，有bin和all可选，指定bin时只会下载二进制文件；all还会下载源码 --gradle-distribution-url：指定Gradle distribution的URL地址，这个参数会覆盖以上的两个参数，在公司内网使用时会经常用到 --gradle-distribution-sha256-sum：下载的Gradle distribution校验码，为了安全起见，建议设置。 123456789101112131415# 指定gradle distribution版本和类型xiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; gradle wrapper --gradle-version 5.3.1 --distribution-type allBUILD SUCCESSFUL in 1s1 actionable task: 1 executedxiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; cat gradle/wrapper/gradle-wrapper.propertiesdistributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/dists# 远程地址的版本和类型和以上设置对应distributionUrl=https\://services.gradle.org/distributions/gradle-5.3.1-all.zipzipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/dists PS:在实际工程中还有一种指定版本和类型的方式是在构建脚本中配置，只需要执行gradle wrapper就好 12345build.gradletask wrapper(type: Wrapper)&#123; gradleVersion = '5.3.1' distributionType = 'bin'&#125; 总结 简单体验了下Gradle，感受到了其灵活和高度可定制，可折腾性不错。 task和plugin是两个重要的东东。 Wrapper好用。]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle系列(一)-Gradle介绍]]></title>
    <url>%2F2019%2F04%2F13%2Fgradle-first-introduce%2F</url>
    <content type="text"><![CDATA[前言：最近在学习Netty，其中看到不少牛牛们的项目工程都是使用gradle构建的，作为一个上（好）进（奇）的程序员，打开了Gradle的官网，了解了一番，这里做个记录。 Gradle官网（学习Gradle的不二之选）https://gradle.org/ Gradle简介Gradle是一个旨在提高开发者效率的构建工具。不管是移动APP还是微服务，不管是小的初创项目或者大型企业级项目，Gradle都可以帮我们更好更快的自动化的构建实现我们的软件项目。 引自wikipedia：Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy（新版还可基于kotlin）的特定领域语言来声明项目设置，而不是传统的XML。 Gradle对比Maven 灵活性Gradle和Maven虽都提供了约定由于配置的机制，但是Maven提供的是一个非常严格，对用户定制不太友好甚至有时无法定制的系统，这也侧面展示了Maven的能力范围，只要你没有一些定制化的特殊需求，Maven基本可以满足大多数需要自动化构建的场景，在这一点上，Gradle就给予了用户更大的灵活度，同时还降低了复杂度。 性能Maven和Gradle都使用了并行构建，并行依赖解析的方式。Gradle区别于Maven最大的地方在于其work avoidance and incrementality机制。最大的3个让Gradle构建更快的原因是： Incrementality：Gradle不会对Task的所有输入进行追踪构建，只会尽量处理被改变了的文件。 Build Cache：充分重用构建以前的构建结果，即便是其他Gradle版本或其他机器上构建出的结果。 Gradle Daemon：后台进程对构建信息进行持续追踪，keeps build information “hot” in memory。 更多性能对比见Gradle vs Maven: Performance Comparison 用户体验Maven作为现在大多数项目默认使用的构建工具，得到了大多数IDE的支持。Gradle这方面还是快速的进步，比如现在Gradle还支持了基于Kotlin DSL进行构建逻辑的定义，使支持Kotlin的的IDE自然的友好支持了Kotlin。除了使用IDE，还有很多用户喜欢使用命令行进行构建，Gradle也提供了待自动提示的命令行工具gradle-completion。 依赖管理Ant与Maven对于Gradle，前者编写容易，但功能有限，需要人工操作的过程也多；后者依托于庞大的依赖仓库，因此有着强大的外部依赖管理，但添加本地依赖并不方便，且项目不能灵活修改。而Gradle能很好地结合Ant与Maven各自的优点，可以随意的编写任务并组合成项目，直接利用Maven仓库，并且能很好的支持传递依赖和内部依赖。]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习 数据预处理之One-Hot Encoding]]></title>
    <url>%2F2018%2F04%2F19%2Fone-hot-encoding%2F</url>
    <content type="text"><![CDATA[看到One-Hot-Encoding发现网上大多数说明都是来自于同一个例子，最后结果感觉出的好突兀，因此这里总结一下。 很多机器学习任务中，特征并不总是连续值，有可能是分类值。 考虑以下三个特征： [“male”, “female”] [“from Europe”, “from US”, “from Asia”] [“uses Firefox”, “uses Chrome”, “uses Safari”, “uses Internet Explorer”] 如果将上述特征用数字表示，效率会高很多。例如： [“male”, “from US”, “uses Internet Explorer”] 表示为[0, 1, 3] [“female”, “from Asia”, “uses Chrome”]表示为[1, 2, 1] 但是，转化为数字表示后，上述数据不能直接用在我们的分类器中。因为，分类器往往默认数据数据是连续的，并且是有序的。但按上述表示的数字并不有序的，而是随机分配的。 One-Hot Encoding解决上述问题的一种方法是采用One-Hot Encoding。 独热编码，又称一位有效编码，其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都有它独立的寄存器位，并且在任意时候，其中只有一位有效。 例如： 自然状态码为：000,001,010,011,100,101 独热编码为：000001,000010,000100,001000,010000,100000 可以这样理解，对于每一个特征，如果它有m个可能值，那么经过独热编码后，就变成了m个二元特征。并且，这些特征互斥，每次只有一个激活。因此，数据会变成稀疏的。 这样做的好处主要有： 解决了分类器不好处理属性数据的问题 在一定程度上也起到了扩充特征的作用 基于python和Scikit-learn的一个简单例子： 123456789encoder = preprocessing.OneHotEncoder()encoder.fit([ [0, 2, 1, 12], [1, 3, 5, 3], [2, 3, 2, 12], [1, 2, 4, 3]])encoded_vector = encoder.transform([[2, 3, 5, 3]]).toarray()print("\n Encoded vector =", encoded_vector) 输出结果： Encoded vector = [[ 0. 0. 1. 0. 1. 0. 0. 0. 1. 1. 0.]] 分析：12345674个特征：第一个特征（即为第一列）为[0,1,2,1] ，其中三类特征值[0,1,2]，因此One-Hot Code可将[0,1,2]表示为:[100,010,001]同理第二个特征列可将两类特征值[2,3]表示为[10,01]第三个特征将4类特征值[1,2,4,5]表示为[1000,0100,0010,0001]第四个特征将2类特征值[3,12]表示为[10,01]因此最后可将[2,3,5,3]表示为[0,0,1,0,1,0,0,0,1,1,0]]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>one-hot</tag>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据Servlet-API源码分析学习Servlet]]></title>
    <url>%2F2018%2F04%2F18%2Fstudy-servlet-source%2F</url>
    <content type="text"><![CDATA[Servlet介于Servlet是Java Web开发的基础，因此好好看了一下Servlet3.0.1的源码，于是有了这篇记录。 Servlet和JSP是众多java EE定义的技术当中的两种，其他还有JMS，EJB等等，运行JEE程序需要一个JEE容器，如GlassFish、JBOSS、WebLogic等，Servlet\JSP也可以部署在JEE容器中，不过用Servlet/JSP容器已经足够了，而且比JEE容器更加轻量化，Tomcat和Jetty不属于JEE容器，不能运行EJB或JMS。 Servlet API概述首先，下载Servlet-api源码，可以使用IDE，maven等方式，本文使用maven下载，命令如下（或者自行搜索下载源码）： 1maven dependency:sources servlet API中有4个Java包，包括： javax.servlet 定义Servlet和Servlet容器之间的七月类和接口。 javax.servlet.http 定义HTTP Servlet与Serlvet容器之间的契约和接口 javax.servlet.annotation 包含对Servlet、Filter和Listener进行标注的注解。还为标注元件指定元数据。 javax.servlet.descriptor 包含为Web应用程序的配置星系提供编程式访问的类型。 javax.servlet包不完整截图： Servlet包中的主要成员： Servlet接口是核心接口，是所有Serlvet都必须直接或间接实现的一个接口，Servlet接口定义了Servlet与Servlet容器之间的约定，总的来说就是Servlet容器会把Servlet类加载到内存中，并在Servlet实例中调用特定方法，在一个应用程序中，每个Servlet类型只能有一个实例。当用户的请求引发service方法，并给这个方法传入一个ServletRequest实例和一个ServletResponse实例。ServletRequest封装当前的HTTP请求，让开发者不必去解析和操作原始的HTTP数据，同理，ServletResponse表示当前用户的HTTP响应，它的作用是使得将响应回传给用户更容易。Servlet容器还为每个应用程序创建一个ServletContext实例。这个对象封装context（应用程序）的环境细节，而每个context只有一个ServletContext。每个Servlet实例还有一个封装Servlet配置信息的ServletConfig。 Servlet下面先看看Servlet接口，（如果别人问你什么是Servlet，你可以告诉他，就是一个java接口，分分钟定义出来给你看，不过人们常说的Servlet应该是指任何实现了Servlet接口的类）看源码发现有234行（3.0.1版），仔细一看也就5个抽象方法，其他的全是注释，所以兄弟们，看源码不要虚，这就是传说中的和Servlet容器之间的约定（有没有很熟悉的感觉）： init 第一次请求我们编写的Serlvet时，Servlet容器调用此方法，后续不在调用，可以利用这个方法做一些初始化的工作。在调用这个方法时，Servlet容器会传递一个ServletConfig。一般会将这个ServletConfig赋给一个类级变量，以方便其他方法也可以使用这个对象。 service 每次用户请求service时，servlet容器都会调用这个方法，我们对请求的处理就是在这里完成的。 destroy 要销毁Servlet时，Servlet容器就会调用这个方法，它通常发生在卸载应用程序，或者关闭Servlet容器的时候，这里一般我们会写一些资源清理相关的代码。 Servlet中另外另个费生命周期的方法：getServletInfo和getServletConfig getServletInfo 就是字面意思，返回Servlet的描述 getServletConfig 这个方法返回由Servlet容器传给init方法的ServletConfig，上面说了，一般在init方法中将ServletConfig赋给一个类级变量，免得本方法返回null。 PS:由于Servlet不是线程安全的，一个应用程序中所有的用户公用一个Servlet实例，因此不建议使用类级别的变量（只使用局部变量最好），除非是只读的或者java.utilconcurrent.atomic包中的成员。 Servlet基础应用程序现在来写一个Servlet应用程序，写起来很简单，只要创建一个目录，并将Servlet类放在指定目录中就可以了，同时，如果要运行这个应用程序，你还需要安装一个Servlet容器，如Tomcat或者Jetty（安装方法自行搜索）。 编写Servlet应用 以上为Servlet的目录结构，要编译servlet，类路径中还要有servlet API，tomcat容器中已经自带了servlet-api.jar。另外珍爱生命，还是用IDE来创建吧，博主试过，自己去一步一步创建配置虽说也可以，但是确实会花费不少时间，如果你就是要自己一步一步创建，觉得这样能学到更多东西，我只能说加油骚年！ 应用程序中一般会有JSP、HTML、图像等其他资源，这些都应该放在应用程序的目录下面，并且经常放在子目录下，如上图，html放在html文件下，jsp放在jsp目录下。放在应用程序目录下的任何资源，用户可以通过资源的URL直接访问（放在应用程序目录下当然要可以访问了），如果希望某个资源可以被Servlet访问，但不能被用户访问，那就应该放在WEB-INF目录下（是不是找到该目录的作用了）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.io.IOException;import java.io.PrintWriter;import javax.servlet.Servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;//name可选，提供servlet名，关键urlPatterns指定匹配当前servlet的模式@WebServlet(name="/FirstServlet",urlPatterns=&#123; "/myapp" &#125;)public class FirstServlet implements Servlet &#123; private transient ServletConfig config; @Override public void init(ServletConfig config) throws ServletException &#123; //将config给类变量，扩大使用范围 this.config=config; &#125; @Override public ServletConfig getServletConfig() &#123; return config; &#125; @Override public String getServletInfo() &#123; return "My Servlet"; &#125; @Override public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException &#123; String servletName=config.getServletName(); response.setContentType("text/html"); PrintWriter pw=response.getWriter(); pw.write("hello from "+servletName); &#125; @Override public void destroy() &#123;&#125;&#125; 以上程序部署完成，启动Servlet容器，就可以通过url在浏览器中访问了： 通过访问 http://localhost:8080/App01/FirstServlet ServletRequest &amp; ServletResponse对于每一个HTTP请求，servlet容器会创建一个封装了HTTP请求的ServletRequest实例传递给servlet的service方法，ServletResponse则表示一个Servlet响应，其影藏了将响应发给浏览器的复杂性。通过ServletRequest的方法你可以获取一些请求相关的参数，而ServletResponse则可以将设置一些返回参数信息，并且设置返回内容。返回内容之前一般会调用setContentType方法设置响应的内容类型，如果没有设置，大多数浏览器会默认以html的形式响应，不过为了避免出问题，我们一般都设置该项。 值得注意的是ServletResponse中定义的getWriter方法，它返回可以将文本传给客户端的java.io.PrintWriter。在默认的情况下，PrintWriter对象使用ISO-8859-1编码，这有可能引起乱码。 以下为ServletRequest和ServletResponse的大部分方法： ServletConfigServletConfig封装可以通过@WebServlet或者web.xml传给一个Servlet的配置信息，以这种方式传递的每一条信息都称做初始化信息，初始化信息就是一个个K-V键值对。为了从一个Servlet内部获取某个初始参数的值，init方法中调用ServletConfig的getinitParameter方法或getinitParameterNames方法获取，除此之外，还可以通过getServletContext获取ServletContext对象。方法签名： 通过WebServlet传递配置信息示例： ServletContextServletContext是代表了Servlet应用程序。每个Web应用程序只有一个context。在分布式环境中，一个应用程序同时部署到多个容器中，并且每台Java虚拟机都有一个ServletContext对象。有了ServletContext对象后，就可以共享能通过应用程序的所有资源访问的信息，促进Web对象的动态注册，共享的信息通过一个内部Map中的对象保存在ServiceContext中来实现。保存在ServletContext中的对象称作属性。操作属性的方法： GenericServlet前面编写的Servlet应用中通过实现Servlet接口来编写Servlet，但是我们每次都必须为Servlet中的所有方法都提供实现，还需要将ServletConfig对象保存到一个类级别的变量中，GenericServlet抽象类就是为了为我们省略一些模板代码，实现了Servlet和ServletConfig，完成了一下几个工作： 将init方法中的ServletConfig赋给一个类级变量，使的可以通过getServletConfig来获取。 1234public void init(ServletConfig config) throws ServletException &#123; this.config = config; this.init(); &#125; 同时为避免覆盖init方法后在子类中必须调用super.init(servletConfig)，GenericServlet还提供了一个不带参数的init方法，当ServletConfig赋值完成就会被第带参数的init方法调用。这样就可以通过覆盖不带参数的init方法编写初始化代码，而ServletConfig实例依然得以保存（这难道不是适配器模式吗？） 为Servlet接口中的所有方法提供默认实现。 提供方法来包装ServletConfig中的方法。 用GenericServlet实现Servlet应用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.io.IOException;import java.io.PrintWriter;import javax.servlet.GenericServlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebInitParam;import javax.servlet.annotation.WebServlet;@WebServlet(name="SecondServlet", urlPatterns=&#123;"/generic"&#125;, initParams=&#123; @WebInitParam(name="user",value="xiaobai"), @WebInitParam(name="email",value="xiaobai@example.com") &#125;)public class SecondServlet extends GenericServlet &#123; @Override public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException &#123; ServletConfig config=getServletConfig(); String user=config.getInitParameter("user"); String email=config.getInitParameter("email"); response.setContentType("text/html"); PrintWriter pw=response.getWriter(); pw.write("User:"+user+"&lt;br&gt;email:"+email); &#125;&#125; HTTPServlet在编写Servlet应用程序时，大多数都要用到HTTP，也就是说可以利用HTTP提供的特性，javax.servlet.http包含了编写Servlet应用程序的类和接口，其中很多覆盖了javax.servlet中的类型，我们自己在编写应用时大多时候也是继承的HttpServlet，以下为其中的重要成员: 从上图看，HttpServlet继承了GenericServlet，HttpServletRequest/Response继承了覆盖了ServletRequest/Response，成为了新的Servlet请求和响应的代表。在HttpServlet中覆盖了GenericServlet的service方法，并用新的Servlet请求和响应代表作为参数添加了一个service方法： 1234567891011121314151617181920//覆盖GenereicServlet中的servicepublic void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; HttpServletRequest request; HttpServletResponse response; if (!(req instanceof HttpServletRequest &amp;&amp; res instanceof HttpServletResponse)) &#123; throw new ServletException("non-HTTP request or response"); &#125; request = (HttpServletRequest) req; response = (HttpServletResponse) res; service(request, response); &#125;&#125;//新service方法签名protected void service(HttpServletRequest req, HttpServletResponse resp) 原始的service方法将请求和响应进行向下转换，分别为HttpServletRequest和HttpServletResponse，并调用新的service方法。看了下2.5版本中的实现，发现没有加以上代码是中的instanceof判断，恩，看来2.5中直接向下转型确实暴力了点，考虑容器不一定总是把请求当做HTTP请求，这样做看起来稳妥了些。新的service方法会查寻HTTP请求的方法从而调用do{Method}来处理请求。 总之HttpServlet中有两项特性是GenericServlet中没有的： 不覆盖service方法，而是覆盖doGet、doPost等。 用HttpServletRequest\Response 替代ServletRequest\Response HttpServletRequest，HttpServletResponse由于带有了HTTP的特性，因此除了ServletRequest，ServletResponse中的方法之外还增加了几个可以获取HTTP特性信息的方法。 12345678910111213141516171819202122232425262728293031323334353637//获取context的请求URI部分java.lang.String getContextPath()//获取Cookie对象数组Cookie [] getCookies()//返回指定HTTP标头的值java.lang.String getHeader(java.lang.String name)//返回发出这条请求的HTTP方法的名称java.lang.String getMethod()//返回请求URL中的查询字符串java.lang.String getQueryString()//获取session对象，没找到就新创建HttpSession getSession()//返回与这个请求相关的session对象，如果没有，并且create参数为true，创建新的session对象//响应对象添加cookievoid addCookie(Cookie cookie)//添加标头void addheader(String name,String value)//重定向void sendRedirect(String location) 使用web.xml配置Servlet应用在Servlet3.x中可以使用@WebServlet来部署应用，可以不必在WEB-INF目录下放一个web.xml配置文件，当然也可以同时使用，前者优先级更高，这是annotation为我们带来的好处，介于使用web.xml来配置Servlet也有其有点，就简单介绍下，使用web.xml配置优点： 不用更改代码，也就意味着不需要重新编译 可包含@WebServlet中没有的元素，如load-on-startup元素，init方法比较费时间这个就很有帮助了。 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;servlet&gt; &lt;servlet-name&gt;SimpleServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;app01.SimpleServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SimpleServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/simple&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 附现在再来看下我们我们通常写的Servlet，看完上文的客官，看到下面Servlet是不是感觉自己看到了更多的东西呢？反正我是看到了。讲真，如果想要缕下Servlet的话，真的可以试一试下载Servlet-api的源码看看，结合本文，或许风味更佳哦！！ 12345678910111213141516171819202122232425262728293031323334353637import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet("/normal")public class NormalServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.getWriter().append("Served at: ").append(request.getContextPath()); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 小结Servlet技术是Java EE技术的重要组成，Servlet容器中运行的所有Servlet，以及容器与Servlet之间的约定，都采用了javax.servlet.Servlet接口的形式。javax.servlet包也提供了实现Servlet接口的GenericServlet抽象类。这是一个比较方便的类，可以通过扩展它来创建Servlet。但是大多数的现代Servlet都在HTTP环境中处理请求，因此提供了javax.servlet.http.HttpServlet来继承GenericServlet并且加入HTTP特性。]]></content>
      <categories>
        <category>servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开篇]]></title>
    <url>%2F2018%2F01%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[一直想好好有个写博客的地方，现在算是正式入坑，好好加油吧，少年！！！]]></content>
  </entry>
</search>
