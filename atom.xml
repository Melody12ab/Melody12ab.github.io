<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bigface Monster</title>
  
  <subtitle>quick note</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://melody12ab.github.io/"/>
  <updated>2019-04-10T15:48:11.643Z</updated>
  <id>http://melody12ab.github.io/</id>
  
  <author>
    <name>Bigface Monster</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习 数据预处理之One-Hot Encoding</title>
    <link href="http://melody12ab.github.io/2018/04/19/one-hot-encoding/"/>
    <id>http://melody12ab.github.io/2018/04/19/one-hot-encoding/</id>
    <published>2018-04-19T14:11:28.000Z</published>
    <updated>2019-04-10T15:48:11.643Z</updated>
    
    <content type="html"><![CDATA[<p>看到One-Hot-Encoding发现网上大多数说明都是来自于同一个例子，最后结果感觉出的好突兀，因此这里总结一下。</p><p>很多机器学习任务中，特征并不总是连续值，有可能是分类值。</p><a id="more"></a><p>考虑以下三个特征：</p><blockquote><p>[“male”, “female”]</p><p>[“from Europe”, “from US”, “from Asia”]</p><p>[“uses Firefox”, “uses Chrome”, “uses Safari”, “uses Internet Explorer”]</p></blockquote><p>如果将上述特征用数字表示，效率会高很多。例如：</p><blockquote><p>[“male”, “from US”, “uses Internet Explorer”] 表示为[0, 1, 3]</p><p>[“female”, “from Asia”, “uses Chrome”]表示为[1, 2, 1]</p></blockquote><p>但是，转化为数字表示后，上述数据不能直接用在我们的分类器中。因为，分类器往往默认数据数据是连续的，并且是有序的。但按上述表示的数字并不有序的，而是随机分配的。</p><h2 id="One-Hot-Encoding"><a href="#One-Hot-Encoding" class="headerlink" title="One-Hot Encoding"></a>One-Hot Encoding</h2><p>解决上述问题的一种方法是采用One-Hot Encoding。</p><p>独热编码，又称一位有效编码，其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都有它独立的寄存器位，并且在任意时候，其中只有一位有效。</p><p>例如：</p><blockquote><p>自然状态码为：000,001,010,011,100,101</p><p>独热编码为：000001,000010,000100,001000,010000,100000</p></blockquote><p>可以这样理解，对于每一个特征，如果它有m个可能值，那么经过独热编码后，就变成了m个二元特征。并且，这些特征互斥，每次只有一个激活。因此，数据会变成稀疏的。</p><p>这样做的好处主要有：</p><ol><li><p>解决了分类器不好处理属性数据的问题</p></li><li><p>在一定程度上也起到了扩充特征的作用</p></li></ol><p>基于python和Scikit-learn的一个简单例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">encoder = preprocessing.OneHotEncoder()</span><br><span class="line">encoder.fit([</span><br><span class="line">    [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">12</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">12</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line">])</span><br><span class="line">encoded_vector = encoder.transform([[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>]]).toarray()</span><br><span class="line">print(<span class="string">"\n Encoded vector ="</span>, encoded_vector)</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>Encoded vector = [[ 0.  0.  1.  0.  1.  0.  0.  0.  1.  1.  0.]]</p></blockquote><p>分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4个特征：</span><br><span class="line">第一个特征（即为第一列）为[0,1,2,1] ，其中三类特征值[0,1,2]，因此One-Hot Code可将[0,1,2]表示为:[100,010,001]</span><br><span class="line">同理第二个特征列可将两类特征值[2,3]表示为[10,01]</span><br><span class="line">第三个特征将4类特征值[1,2,4,5]表示为[1000,0100,0010,0001]</span><br><span class="line">第四个特征将2类特征值[3,12]表示为[10,01]</span><br><span class="line"></span><br><span class="line">因此最后可将[2,3,5,3]表示为[0,0,1,0,1,0,0,0,1,1,0]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到One-Hot-Encoding发现网上大多数说明都是来自于同一个例子，最后结果感觉出的好突兀，因此这里总结一下。&lt;/p&gt;
&lt;p&gt;很多机器学习任务中，特征并不总是连续值，有可能是分类值。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://melody12ab.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="one-hot" scheme="http://melody12ab.github.io/tags/one-hot/"/>
    
      <category term="machine learning" scheme="http://melody12ab.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>根据Servlet-API源码分析学习Servlet</title>
    <link href="http://melody12ab.github.io/2018/04/18/study-servlet-source/"/>
    <id>http://melody12ab.github.io/2018/04/18/study-servlet-source/</id>
    <published>2018-04-18T05:23:54.000Z</published>
    <updated>2019-04-10T15:48:25.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>介于Servlet是Java Web开发的基础，因此好好看了一下Servlet3.0.1的源码，于是有了这篇记录。<br><img src="http://upload-images.jianshu.io/upload_images/356003-58baa54b8e0aa008.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Servlet架构图"></p><blockquote><p>Servlet和JSP是众多java EE定义的技术当中的两种，其他还有JMS，EJB等等，运行JEE程序需要一个JEE容器，如GlassFish、JBOSS、WebLogic等，Servlet\JSP也可以部署在JEE容器中，不过用Servlet/JSP容器已经足够了，而且比JEE容器更加轻量化，Tomcat和Jetty不属于JEE容器，不能运行EJB或JMS。</p></blockquote><a id="more"></a><h2 id="Servlet-API概述"><a href="#Servlet-API概述" class="headerlink" title="Servlet API概述"></a>Servlet API概述</h2><p>首先，下载Servlet-api源码，可以使用IDE，maven等方式，本文使用maven下载，命令如下（或者自行搜索下载源码）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maven dependency:sources</span><br></pre></td></tr></table></figure><p>servlet API中有4个Java包，包括：</p><ul><li><p>javax.servlet    定义Servlet和Servlet容器之间的七月类和接口。</p></li><li><p>javax.servlet.http    定义HTTP Servlet与Serlvet容器之间的契约和接口</p></li><li><p>javax.servlet.annotation  包含对Servlet、Filter和Listener进行标注的注解。还为标注元件指定元数据。</p></li><li><p>javax.servlet.descriptor    包含为Web应用程序的配置星系提供编程式访问的类型。</p></li></ul><h3 id="javax-servlet包"><a href="#javax-servlet包" class="headerlink" title="javax.servlet包"></a>javax.servlet包</h3><p>不完整截图：</p><p><img src="http://upload-images.jianshu.io/upload_images/356003-d4d4306658e2e6b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="javax.servlet方法一览"></p><p>Servlet包中的主要成员：</p><p><img src="http://upload-images.jianshu.io/upload_images/356003-389e831617d5ca8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Servlet主要成员"></p><p>Servlet接口是核心接口，是所有Serlvet都必须直接或间接实现的一个接口，Servlet接口定义了Servlet与Servlet容器之间的约定，总的来说就是Servlet容器会把Servlet类加载到内存中，并在Servlet实例中调用特定方法，在一个应用程序中，每个Servlet类型只能有一个实例。当用户的请求引发service方法，并给这个方法传入一个ServletRequest实例和一个ServletResponse实例。ServletRequest封装当前的HTTP请求，让开发者不必去解析和操作原始的HTTP数据，同理，ServletResponse表示当前用户的HTTP响应，它的作用是使得将响应回传给用户更容易。Servlet容器还为每个应用程序创建一个ServletContext实例。这个对象封装context（应用程序）的环境细节，而每个context只有一个ServletContext。每个Servlet实例还有一个封装Servlet配置信息的ServletConfig。</p><h3 id="Servlet-1"><a href="#Servlet-1" class="headerlink" title="Servlet"></a>Servlet</h3><p>下面先看看Servlet接口，（如果别人问你什么是Servlet，你可以告诉他，就是一个java接口，分分钟定义出来给你看，不过人们常说的Servlet应该是指任何实现了Servlet接口的类）看源码发现有234行（3.0.1版），仔细一看也就5个抽象方法，其他的全是注释，所以兄弟们，看源码不要虚，这就是传说中的和Servlet容器之间的约定（有没有很熟悉的感觉）：</p><p><img src="http://upload-images.jianshu.io/upload_images/356003-dff109fe771f3fc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Servlet接口"></p><ul><li><p>init 第一次请求我们编写的Serlvet时，Servlet容器调用此方法，后续不在调用，可以利用这个方法做一些初始化的工作。在调用这个方法时，Servlet容器会传递一个ServletConfig。一般会将这个ServletConfig赋给一个类级变量，以方便其他方法也可以使用这个对象。</p></li><li><p>service 每次用户请求service时，servlet容器都会调用这个方法，我们对请求的处理就是在这里完成的。</p></li><li><p>destroy 要销毁Servlet时，Servlet容器就会调用这个方法，它通常发生在卸载应用程序，或者关闭Servlet容器的时候，这里一般我们会写一些资源清理相关的代码。</p></li></ul><p>Servlet中另外另个费生命周期的方法：getServletInfo和getServletConfig</p><ul><li><p>getServletInfo 就是字面意思，返回Servlet的描述</p></li><li><p>getServletConfig 这个方法返回由Servlet容器传给init方法的ServletConfig，上面说了，一般在init方法中将ServletConfig赋给一个类级变量，免得本方法返回null。</p></li></ul><blockquote><p>PS:由于Servlet不是线程安全的，一个应用程序中所有的用户公用一个Servlet实例，因此不建议使用类级别的变量（只使用局部变量最好），除非是只读的或者java.utilconcurrent.atomic包中的成员。</p></blockquote><h3 id="Servlet基础应用程序"><a href="#Servlet基础应用程序" class="headerlink" title="Servlet基础应用程序"></a>Servlet基础应用程序</h3><p>现在来写一个Servlet应用程序，写起来很简单，只要创建一个目录，并将Servlet类放在指定目录中就可以了，同时，如果要运行这个应用程序，你还需要安装一个Servlet容器，如Tomcat或者Jetty（安装方法自行搜索）。</p><h4 id="编写Servlet应用"><a href="#编写Servlet应用" class="headerlink" title="编写Servlet应用"></a>编写Servlet应用</h4><p><img src="http://upload-images.jianshu.io/upload_images/356003-10e0cf754d6ab495.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Servlet应用目录结构"></p><p>以上为Servlet的目录结构，要编译servlet，类路径中还要有servlet API，tomcat容器中已经自带了servlet-api.jar。另外珍爱生命，还是用IDE来创建吧，博主试过，自己去一步一步创建配置虽说也可以，但是确实会花费不少时间，如果你就是要自己一步一步创建，觉得这样能学到更多东西，我只能说加油骚年！</p><p>应用程序中一般会有JSP、HTML、图像等其他资源，这些都应该放在应用程序的目录下面，并且经常放在子目录下，如上图，html放在html文件下，jsp放在jsp目录下。放在应用程序目录下的任何资源，用户可以通过资源的URL直接访问（放在应用程序目录下当然要可以访问了），如果希望某个资源可以被Servlet访问，但不能被用户访问，那就应该放在WEB-INF目录下（是不是找到该目录的作用了）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//name可选，提供servlet名，关键urlPatterns指定匹配当前servlet的模式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(name=<span class="string">"/FirstServlet"</span>,urlPatterns=&#123; <span class="string">"/myapp"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ServletConfig config;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将config给类变量，扩大使用范围</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.config=config;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> config;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"My Servlet"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">String servletName=config.getServletName();</span><br><span class="line"></span><br><span class="line">response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">PrintWriter pw=response.getWriter();</span><br><span class="line"></span><br><span class="line">pw.write(<span class="string">"hello from "</span>+servletName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序部署完成，启动Servlet容器，就可以通过url在浏览器中访问了：</p><p>通过访问  <a href="http://localhost:8080/App01/FirstServlet" target="_blank" rel="noopener">http://localhost:8080/App01/FirstServlet</a></p><p><img src="http://upload-images.jianshu.io/upload_images/356003-3f3e129d51d92cfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><h3 id="ServletRequest-amp-ServletResponse"><a href="#ServletRequest-amp-ServletResponse" class="headerlink" title="ServletRequest &amp; ServletResponse"></a>ServletRequest &amp; ServletResponse</h3><p>对于每一个HTTP请求，servlet容器会创建一个封装了HTTP请求的ServletRequest实例传递给servlet的service方法，ServletResponse则表示一个Servlet响应，其影藏了将响应发给浏览器的复杂性。通过ServletRequest的方法你可以获取一些请求相关的参数，而ServletResponse则可以将设置一些返回参数信息，并且设置返回内容。返回内容之前一般会调用setContentType方法设置响应的内容类型，如果没有设置，大多数浏览器会默认以html的形式响应，不过为了避免出问题，我们一般都设置该项。</p><p>值得注意的是ServletResponse中定义的getWriter方法，它返回可以将文本传给客户端的java.io.PrintWriter。在默认的情况下，PrintWriter对象使用ISO-8859-1编码，这有可能引起乱码。</p><p>以下为ServletRequest和ServletResponse的大部分方法：</p><p><img src="http://upload-images.jianshu.io/upload_images/356003-a38efde98fe9cea7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ServletRequest"></p><p><img src="http://upload-images.jianshu.io/upload_images/356003-5e37d367f8dade03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ServletResponse"></p><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><p>ServletConfig封装可以通过@WebServlet或者web.xml传给一个Servlet的配置信息，以这种方式传递的每一条信息都称做初始化信息，初始化信息就是一个个K-V键值对。为了从一个Servlet内部获取某个初始参数的值，init方法中调用ServletConfig的getinitParameter方法或getinitParameterNames方法获取，除此之外，还可以通过getServletContext获取ServletContext对象。方法签名：</p><p><img src="http://upload-images.jianshu.io/upload_images/356003-e5cf0944e8282e38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ServletConfig"></p><p>通过WebServlet传递配置信息示例：</p><p><img src="http://upload-images.jianshu.io/upload_images/356003-7b94c480efae89c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WebServlet初始化参数"></p><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>ServletContext是代表了Servlet应用程序。每个Web应用程序只有一个context。在分布式环境中，一个应用程序同时部署到多个容器中，并且每台Java虚拟机都有一个ServletContext对象。有了ServletContext对象后，就可以共享能通过应用程序的所有资源访问的信息，促进Web对象的动态注册，共享的信息通过一个内部Map中的对象保存在ServiceContext中来实现。保存在ServletContext中的对象称作属性。操作属性的方法：</p><p><img src="http://upload-images.jianshu.io/upload_images/356003-2a888d782664b6ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ServletContext"></p><h3 id="GenericServlet"><a href="#GenericServlet" class="headerlink" title="GenericServlet"></a>GenericServlet</h3><p>前面编写的Servlet应用中通过实现Servlet接口来编写Servlet，但是我们每次都必须为Servlet中的所有方法都提供实现，还需要将ServletConfig对象保存到一个类级别的变量中，GenericServlet抽象类就是为了为我们省略一些模板代码，实现了Servlet和ServletConfig，完成了一下几个工作：</p><ul><li>将init方法中的ServletConfig赋给一个类级变量，使的可以通过getServletConfig来获取。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.config = config;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>同时为避免覆盖init方法后在子类中必须调用super.init(servletConfig)，GenericServlet还提供了一个不带参数的init方法，当ServletConfig赋值完成就会被第带参数的init方法调用。这样就可以通过覆盖不带参数的init方法编写初始化代码，而ServletConfig实例依然得以保存（这难道不是适配器模式吗？）</p><ul><li><p>为Servlet接口中的所有方法提供默认实现。</p></li><li><p>提供方法来包装ServletConfig中的方法。</p></li></ul><p>用GenericServlet实现Servlet应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.GenericServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebInitParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(name=<span class="string">"SecondServlet"</span>,</span><br><span class="line"></span><br><span class="line">     urlPatterns=&#123;<span class="string">"/generic"</span>&#125;,</span><br><span class="line"></span><br><span class="line">     initParams=&#123;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@WebInitParam</span>(name=<span class="string">"user"</span>,value=<span class="string">"xiaobai"</span>),</span><br><span class="line"></span><br><span class="line">         <span class="meta">@WebInitParam</span>(name=<span class="string">"email"</span>,value=<span class="string">"xiaobai@example.com"</span>)</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">         ServletConfig config=getServletConfig();</span><br><span class="line"></span><br><span class="line">         String user=config.getInitParameter(<span class="string">"user"</span>);</span><br><span class="line"></span><br><span class="line">         String email=config.getInitParameter(<span class="string">"email"</span>);</span><br><span class="line"></span><br><span class="line">         response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">         PrintWriter pw=response.getWriter();</span><br><span class="line"></span><br><span class="line">         pw.write(<span class="string">"User:"</span>+user+<span class="string">"&lt;br&gt;email:"</span>+email);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HTTPServlet"><a href="#HTTPServlet" class="headerlink" title="HTTPServlet"></a>HTTPServlet</h3><p>在编写Servlet应用程序时，大多数都要用到HTTP，也就是说可以利用HTTP提供的特性，javax.servlet.http包含了编写Servlet应用程序的类和接口，其中很多覆盖了javax.servlet中的类型，我们自己在编写应用时大多时候也是继承的HttpServlet，以下为其中的重要成员:</p><p><img src="http://upload-images.jianshu.io/upload_images/356003-dffa75f6ab2e7ba1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HttpServelt主要成员"></p><p>从上图看，HttpServlet继承了GenericServlet，HttpServletRequest/Response继承了覆盖了ServletRequest/Response，成为了新的Servlet请求和响应的代表。在HttpServlet中覆盖了GenericServlet的service方法，并用新的Servlet请求和响应代表作为参数添加了一个service方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//覆盖GenereicServlet中的service</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">           HttpServletRequest  request;</span><br><span class="line">           HttpServletResponse response;</span><br><span class="line">           <span class="keyword">if</span> (!(req <span class="keyword">instanceof</span> HttpServletRequest &amp;&amp;</span><br><span class="line">                   res <span class="keyword">instanceof</span> HttpServletResponse)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"non-HTTP request or response"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           request = (HttpServletRequest) req;</span><br><span class="line">           response = (HttpServletResponse) res;</span><br><span class="line">           service(request, response);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新service方法签名</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br></pre></td></tr></table></figure><p>原始的service方法将请求和响应进行向下转换，分别为HttpServletRequest和HttpServletResponse，并调用新的service方法。看了下2.5版本中的实现，发现没有加以上代码是中的instanceof判断，恩，看来2.5中直接向下转型确实暴力了点，考虑容器不一定总是把请求当做HTTP请求，这样做看起来稳妥了些。新的service方法会查寻HTTP请求的方法从而调用do{Method}来处理请求。</p><p>总之HttpServlet中有两项特性是GenericServlet中没有的：</p><ul><li><p>不覆盖service方法，而是覆盖doGet、doPost等。</p></li><li><p>用HttpServletRequest\Response 替代ServletRequest\Response</p></li></ul><p>HttpServletRequest，HttpServletResponse由于带有了HTTP的特性，因此除了ServletRequest，ServletResponse中的方法之外还增加了几个可以获取HTTP特性信息的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取context的请求URI部分</span></span><br><span class="line"></span><br><span class="line">java.lang.<span class="function">String <span class="title">getContextPath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//获取Cookie对象数组</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Cookie [] <span class="title">getCookies</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回指定HTTP标头的值</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">java.lang.String <span class="title">getHeader</span><span class="params">(java.lang.String name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回发出这条请求的HTTP方法的名称</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">java.lang.String <span class="title">getMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回请求URL中的查询字符串</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">java.lang.String <span class="title">getQueryString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//获取session对象，没找到就新创建</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">HttpSession <span class="title">getSession</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回与这个请求相关的session对象，如果没有，并且create参数为true，创建新的session对象</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//响应对象添加cookie</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addCookie</span><span class="params">(Cookie cookie)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//添加标头</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addheader</span><span class="params">(String name,String value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//重定向</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendRedirect</span><span class="params">(String location)</span></span></span><br></pre></td></tr></table></figure><h3 id="使用web-xml配置Servlet应用"><a href="#使用web-xml配置Servlet应用" class="headerlink" title="使用web.xml配置Servlet应用"></a>使用web.xml配置Servlet应用</h3><p>在Servlet3.x中可以使用@WebServlet来部署应用，可以不必在WEB-INF目录下放一个web.xml配置文件，当然也可以同时使用，前者优先级更高，这是annotation为我们带来的好处，介于使用web.xml来配置Servlet也有其有点，就简单介绍下，使用web.xml配置优点：</p><ul><li><p>不用更改代码，也就意味着不需要重新编译</p></li><li><p>可包含@WebServlet中没有的元素，如load-on-startup元素，init方法比较费时间这个就很有帮助了。</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SimpleServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>app01.SimpleServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SimpleServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/simple<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><p>现在再来看下我们我们通常写的Servlet，看完上文的客官，看到下面Servlet是不是感觉自己看到了更多的东西呢？反正我是看到了。讲真，如果想要缕下Servlet的话，真的可以试一试下载Servlet-api的源码看看，结合本文，或许风味更佳哦！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/normal"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">response.getWriter().append(<span class="string">"Served at: "</span>).append(request.getContextPath());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">doGet(request, response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Servlet技术是Java EE技术的重要组成，Servlet容器中运行的所有Servlet，以及容器与Servlet之间的约定，都采用了javax.servlet.Servlet接口的形式。javax.servlet包也提供了实现Servlet接口的GenericServlet抽象类。这是一个比较方便的类，可以通过扩展它来创建Servlet。但是大多数的现代Servlet都在HTTP环境中处理请求，因此提供了javax.servlet.http.HttpServlet来继承GenericServlet并且加入HTTP特性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Servlet&quot;&gt;&lt;a href=&quot;#Servlet&quot; class=&quot;headerlink&quot; title=&quot;Servlet&quot;&gt;&lt;/a&gt;Servlet&lt;/h1&gt;&lt;p&gt;介于Servlet是Java Web开发的基础，因此好好看了一下Servlet3.0.1的源码，于是有了这篇记录。&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/356003-58baa54b8e0aa008.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Servlet架构图&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Servlet和JSP是众多java EE定义的技术当中的两种，其他还有JMS，EJB等等，运行JEE程序需要一个JEE容器，如GlassFish、JBOSS、WebLogic等，Servlet\JSP也可以部署在JEE容器中，不过用Servlet/JSP容器已经足够了，而且比JEE容器更加轻量化，Tomcat和Jetty不属于JEE容器，不能运行EJB或JMS。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="servlet" scheme="http://melody12ab.github.io/categories/servlet/"/>
    
    
      <category term="servlet" scheme="http://melody12ab.github.io/tags/servlet/"/>
    
      <category term="java" scheme="http://melody12ab.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>开篇</title>
    <link href="http://melody12ab.github.io/2018/01/01/hello-world/"/>
    <id>http://melody12ab.github.io/2018/01/01/hello-world/</id>
    <published>2017-12-31T16:00:00.000Z</published>
    <updated>2019-04-10T15:43:53.401Z</updated>
    
    <content type="html"><![CDATA[<p>一直想好好有个写博客的地方，现在算是正式入坑，好好加油吧，少年！！！</p><p><img src="/images/ydcb.jpeg" alt="Castle"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直想好好有个写博客的地方，现在算是正式入坑，好好加油吧，少年！！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/ydcb.jpeg&quot; alt=&quot;Castle&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
