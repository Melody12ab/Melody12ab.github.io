<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bigface Monster</title>
  
  <subtitle>BigMama’s daliy note</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://melody12ab.github.io/"/>
  <updated>2019-04-13T17:50:59.957Z</updated>
  <id>http://melody12ab.github.io/</id>
  
  <author>
    <name>Bigface Monster</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Gradle系列(二)-使用Gradle构建项目</title>
    <link href="http://melody12ab.github.io/2019/04/13/gradle-second-create-build/"/>
    <id>http://melody12ab.github.io/2019/04/13/gradle-second-create-build/</id>
    <published>2019-04-13T08:12:30.000Z</published>
    <updated>2019-04-13T17:50:59.957Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/04/13/5cb18aedb6b14.png" alt="WX20190413-150809@2x.png"></p><blockquote><p>上一篇文章中简单介绍了一下Gradle，既然从扩展性、灵活性、性能方面都这么出色，那这次就动手尝试看看如何使用Gradle来构建项目。<br><a id="more"></a> </p></blockquote><h3 id="Gradle安装"><a href="#Gradle安装" class="headerlink" title="Gradle安装"></a>Gradle安装</h3><p>安装可参见官方文档<a href="https://gradle.org/install/" target="_blank" rel="noopener">Gradle Installation</a>，todo推荐使用gradlew来管理项目，用过的人都说好，后面会介绍下gradlew的最佳实践。本机环境如下图：<br><img src="https://i.loli.net/2019/04/13/5cb1e8d671402.png" alt="WX20190413-214844@2x.png"></p><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; mkdir gradle_demo</span><br><span class="line">&gt; cd gradle_demo</span><br><span class="line">&gt; gradle init</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/13/5cb1e851ad58a.png" alt="WX20190413-214646@2x.png"><br>如上图所示gradle可以支持cpp、grovvy、java、kotlin类型的项目构建，同时可以使用groovy和kotlin做为DSL，看起来还不错，看下初始化后的项目结构：<br><img src="https://i.loli.net/2019/04/13/5cb1e9a1c4890.png" alt="WX20190413-215216@2x.png"></p><p>目前新版的Gradle在执行初始化时会自动将gradle wrapper plugin应用于项目。介绍下期中的几个文件：</p><ul><li>build.gradle：当前项目的构建脚本（类似于maven的pom.xml）</li><li>gradle-wrapper.jar：gradle wrapper可执行jar包</li><li>gradle-wrapper.properties：gradle wapper配置文件</li><li>gradlew：gradle wrapper unix-base系统下的可执行脚本</li><li>gradlew.bat：gradle wrapper Windows系统下的可执行脚本</li><li>settings.gradle：当前项目的配置文件</li></ul><blockquote><p>gradle init还可以将pom.xml”翻译”为Gradle项目，使用<code>-p pom.xml</code></p></blockquote><h3 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h3><p>Gradle提供了丰富的API给我们使用基于Groovy或者Kotlin的DSL来创建和配置tasks，一个项目工程包含了一系列的Task，每个Task完成一些基本的操作，最后完成我们整个项目的构建。</p><p>Gradle给我们提供了一个方便我们构建项目的基本<strong><a href="https://docs.gradle.org/4.10-rc-2/dsl/org.gradle.api.tasks.Copy.html" target="_blank" rel="noopener">Task类型库</a></strong>，这里试一试其中的Copy Task。创建一个src目录，在其中添加一个myCopyFile.txt文件（内容为Hello World!）,定义一个Copy任务如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">build.gradle</span><br><span class="line">task copy(</span><br><span class="line"><span class="symbol">    type:</span> Copy, </span><br><span class="line"><span class="symbol">    group:</span> <span class="string">"MyCopyGroup"</span>, </span><br><span class="line"><span class="symbol">    description:</span> <span class="string">"Copy File Task"</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        from <span class="string">"src"</span></span><br><span class="line">        into <span class="string">"dest"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行Task，发现自动为我们创建了dest目录，并将myCopyFile.txt copy到了目标目录，Gradle正是通过这种强大的任务定义机制以及描述性丰富的DSL满足了我们各种定制需求，这点还是很不错的。（想想这个要在maven中实现麻烦多了）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">xiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; ./gradlew copy                      19-04-13 22:27</span><br><span class="line">Downloading https://services.gradle.org/distributions/gradle-5.3.1-bin.zip</span><br><span class="line">...................................................................................</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> 36s</span><br><span class="line">1 actionable task: 1 executed</span><br><span class="line">xiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; tree                                19-04-13 22:28</span><br><span class="line">.</span><br><span class="line">├── build.gradle</span><br><span class="line">├── dest</span><br><span class="line">│   └── myCopyFile.txt</span><br><span class="line">├── gradle</span><br><span class="line">│   └── wrapper</span><br><span class="line">│       ├── gradle-wrapper.jar</span><br><span class="line">│       └── gradle-wrapper.properties</span><br><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line">├── settings.gradle</span><br><span class="line">└── src</span><br><span class="line">    └── myCopyFile.txt</span><br><span class="line"></span><br><span class="line">4 directories, 8 files</span><br><span class="line">xiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; cat dest/myCopyFile.txt             19-04-13 22:31</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h3 id="应用插件"><a href="#应用插件" class="headerlink" title="应用插件"></a>应用插件</h3><p>插件可以理解为一系列task的集合，Gradle提供了很丰富的<a href="https://docs.gradle.org/4.10-rc-2/userguide/base_plugin.html" target="_blank" rel="noopener">基础插件</a>，另外还有很多<a href="http://plugins.gradle.org/" target="_blank" rel="noopener">第三方插件</a>，其中<code>base</code>插件提供了大多数项目生命周期中都有的task。如下任务利用base插件和Zip打包我们的src目录：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">build.gradle</span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">"base"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task zip(</span><br><span class="line"><span class="symbol">    type:</span> Zip, </span><br><span class="line"><span class="symbol">    group:</span> <span class="string">"Archive"</span>, </span><br><span class="line"><span class="symbol">    description:</span> <span class="string">"Archives src"</span>) &#123;</span><br><span class="line">        from <span class="string">"src"</span></span><br><span class="line">        setArchiveName <span class="string">"gradle-demo-1.0.zip"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行zip任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">xiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; ./gradlew zip                       19-04-13 22:53</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> 1s</span><br><span class="line">1 actionable task: 1 executed</span><br><span class="line">xiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; tree                                19-04-13 22:53</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   └── distributions</span><br><span class="line">│       └── gradle-demo-1.0.zip</span><br><span class="line">├── build.gradle</span><br><span class="line">├── dest</span><br><span class="line">│   └── myCopyFile.txt</span><br><span class="line">├── gradle</span><br><span class="line">│   └── wrapper</span><br><span class="line">│       ├── gradle-wrapper.jar</span><br><span class="line">│       └── gradle-wrapper.properties</span><br><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line">├── settings.gradle</span><br><span class="line">└── src</span><br><span class="line">    └── myCopyFile.txt</span><br><span class="line"></span><br><span class="line">6 directories, 9 files</span><br></pre></td></tr></table></figure><h3 id="探索-amp-build-scan"><a href="#探索-amp-build-scan" class="headerlink" title="探索 &amp; build scan"></a>探索 &amp; build scan</h3><p>更多Gradle使用方法可以查看官方的<a href="https://docs.gradle.org/4.10-rc-2/userguide/command_line_interface.html" target="_blank" rel="noopener">CLI Interface</a>，在项目中查询有哪些可用的task可使用<code>gradlew task</code>，会列出我们自己定义的任务以及plugin引入的任务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">xiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; ./gradlew tasks                     19-04-13 23:00</span><br><span class="line"></span><br><span class="line">&gt; Task :tasks</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Tasks runnable from root project</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Archive tasks</span><br><span class="line">-------------</span><br><span class="line">zip - Archives src</span><br><span class="line"></span><br><span class="line">Build tasks</span><br><span class="line">-----------</span><br><span class="line">assemble - Assembles the outputs of this project.</span><br><span class="line">build - Assembles and tests this project.</span><br><span class="line">clean - Deletes the build directory.</span><br><span class="line"></span><br><span class="line">Build Setup tasks</span><br><span class="line">-----------------</span><br><span class="line">init - Initializes a new Gradle build.</span><br><span class="line">wrapper - Generates Gradle wrapper files.</span><br><span class="line"></span><br><span class="line">Help tasks</span><br><span class="line">----------</span><br><span class="line">buildEnvironment - Displays all buildscript dependencies declared <span class="keyword">in</span> root project <span class="string">'gradle_demo'</span>.</span><br><span class="line">components - Displays the components produced by root project <span class="string">'gradle_demo'</span>. [incubating]</span><br><span class="line">dependencies - Displays all dependencies declared <span class="keyword">in</span> root project <span class="string">'gradle_demo'</span>.</span><br><span class="line">dependencyInsight - Displays the insight into a specific dependency <span class="keyword">in</span> root project <span class="string">'gradle_demo'</span>.</span><br><span class="line">dependentComponents - Displays the dependent components of components <span class="keyword">in</span> root project <span class="string">'gradle_demo'</span>. [incubating]</span><br><span class="line"><span class="built_in">help</span> - Displays a <span class="built_in">help</span> message.</span><br><span class="line">model - Displays the configuration model of root project <span class="string">'gradle_demo'</span>. [incubating]</span><br><span class="line">projects - Displays the sub-projects of root project <span class="string">'gradle_demo'</span>.</span><br><span class="line">properties - Displays the properties of root project <span class="string">'gradle_demo'</span>.</span><br><span class="line">tasks - Displays the tasks runnable from root project <span class="string">'gradle_demo'</span>.</span><br><span class="line"></span><br><span class="line">Verification tasks</span><br><span class="line">------------------</span><br><span class="line">check - Runs all checks.</span><br><span class="line"></span><br><span class="line">Rules</span><br><span class="line">-----</span><br><span class="line">Pattern: clean&lt;TaskName&gt;: Cleans the output files of a task.</span><br><span class="line">Pattern: build&lt;ConfigurationName&gt;: Assembles the artifacts of a configuration.</span><br><span class="line">Pattern: upload&lt;ConfigurationName&gt;: Assembles and uploads the artifacts belonging to a configuration.</span><br><span class="line"></span><br><span class="line">To see all tasks and more detail, run gradlew tasks --all</span><br><span class="line"></span><br><span class="line">To see more detail about a task, run gradlew <span class="built_in">help</span> --task &lt;task&gt;</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> 0s</span><br><span class="line">1 actionable task: 1 executed</span><br></pre></td></tr></table></figure><p>查询项目设置以及默认的属性信息可使用<code>gradlew properties</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">xiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; ./gradlew properties                19-04-13 23:04</span><br><span class="line"></span><br><span class="line">&gt; Task :properties</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Root project</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">allprojects: [root project <span class="string">'gradle_demo'</span>]</span><br><span class="line">ant: org.gradle.api.internal.project.DefaultAntBuilder@2a1a50e0</span><br><span class="line">antBuilderFactory: org.gradle.api.internal.project.DefaultAntBuilderFactory@4d2d5ed3</span><br><span class="line">archivesBaseName: gradle_demo</span><br><span class="line">artifacts: org.gradle.api.internal.artifacts.dsl.DefaultArtifactHandler_Decorated@46b8f540</span><br><span class="line">asDynamicObject: DynamicObject <span class="keyword">for</span> root project <span class="string">'gradle_demo'</span></span><br><span class="line">baseClassLoaderScope: org.gradle.api.internal.initialization.DefaultClassLoaderScope@35e7668d</span><br><span class="line">buildDir: /Users/xiaobai/gradle_study/gradle_demo/build</span><br><span class="line">buildFile: /Users/xiaobai/gradle_study/gradle_demo/build.gradle</span><br><span class="line">……………………………… many properties</span><br><span class="line">state: project state <span class="string">'EXECUTED'</span></span><br><span class="line">status: integration</span><br><span class="line">subprojects: []</span><br><span class="line">tasks: task <span class="built_in">set</span></span><br><span class="line">version: unspecified</span><br><span class="line">zip: task <span class="string">':zip'</span></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> 1s</span><br><span class="line">1 actionable task: 1 executed</span><br></pre></td></tr></table></figure><p>还有一个特别值得提的功能是Gradle为我们提供了一个丰富的，基于Web的分析工具<strong><a href="https://scans.gradle.com/?_ga=2.73106003.1585286202.1555007480-1393214239.1554447513" target="_blank" rel="noopener">build scan</a></strong>，通过使用<code>--scan</code>的命令选项或在项目构建脚本中加入build scan插件，可以将我们的build scans结果发布到Gradle的服务上（也提供了企业级服务），并通一个生成的Web链接访问，这极大的方便了我们对构建过程的分析以及问题的排查。（对比当年maven构建除了问题，将整个错误日志贴出来问牛牛们，方便太多了）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; ./gradlew zip --scan                19-04-13 22:58</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> 9s</span><br><span class="line">1 actionable task: 1 up-to-date</span><br><span class="line"></span><br><span class="line">Publishing a build scan to scans.gradle.com requires accepting the Gradle Terms of Service defined at https://gradle.com/terms-of-service. Do you accept these terms? [yes, no] yes</span><br><span class="line"></span><br><span class="line">Gradle Terms of Service accepted.</span><br><span class="line"></span><br><span class="line">Publishing build scan...</span><br><span class="line">https://gradle.com/s/ohwhkuety36oc</span><br></pre></td></tr></table></figure><p>访问以上生成的build scan链接：<a href="https://gradle.com/s/ohwhkuety36oc" target="_blank" rel="noopener">https://gradle.com/s/ohwhkuety36oc</a><br><img src="https://i.loli.net/2019/04/13/5cb1fdc60b067.png" alt="WX20190413-231815@2x.png"></p><h3 id="gradle-wrapper"><a href="#gradle-wrapper" class="headerlink" title="gradle wrapper"></a>gradle wrapper</h3><p>官方推荐的使用Gradle进行项目构建的方式是使用Gradle Wrapper（后文简称Wrapper），Wrapper是一个使用我们声明的一个gradle版本（如果不存在就预先下载）进行项目构建的脚本，使开发者们可以在自己本地没有安装Gradle的情况下进行项目构建等操作。以下为Wrapper的工作流：<br><img src="https://docs.gradle.org/5.3.1/userguide/img/wrapper-workflow.png" alt="Wrapper 工作流"><br>好处：</p><ul><li>统一构建项目的gradle的版本，避免版本不同导致的构建问题（gradle的版本相比maven非常多）</li><li>修改或升级gradle版本非常方便</li></ul><h4 id="为我们的项目添加Gradle-Wrapper"><a href="#为我们的项目添加Gradle-Wrapper" class="headerlink" title="为我们的项目添加Gradle Wrapper"></a>为我们的项目添加Gradle Wrapper</h4><p>如上文中我使用的版本在执行初始化时，自动引入了Wrapper。但是当我们在使用老版本或需要为没有添加Wrapper的项目添加Wrapper时，可使用<code>gradle wrapper</code>为我们的项目添加Wrapper支持。生成的Wrapper文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; tree gradle                         19-04-13 23:06</span><br><span class="line">gradle</span><br><span class="line">└── wrapper</span><br><span class="line">    ├── gradle-wrapper.jar</span><br><span class="line">    └── gradle-wrapper.properties</span><br><span class="line"></span><br><span class="line">1 directory, 2 files</span><br></pre></td></tr></table></figure><p>在实际开发中，为了让Wrapper对其他开发者也有效，需要将这个目录添加到版本控制中。<code>gradle-wrapper.properties</code>文件中存放着Gradle的基本信息：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line"># 我们使用的Gradle远程地址以及版本</span><br><span class="line">distributionUrl=https\:<span class="comment">//services.gradle.org/distributions/gradle-5.3.1-bin.zip</span></span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br><span class="line"># 文件校验码</span><br><span class="line">distributionSha256Sum=<span class="number">371</span>cb9fbebbe9880d147f59bab36d61eee122854ef8c9ee1ecf12b82368bcf10</span><br></pre></td></tr></table></figure><p>所有以上的属性都可以通过生成Wrapper时通过指定一下参数来设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--gradle-version：指定Gradle版本</span><br><span class="line"> </span><br><span class="line">--distribution-type：指定Gradle distribution的类型，有bin和all可选，指定bin时只会下载二进制文件；all还会下载源码  </span><br><span class="line">  </span><br><span class="line">--gradle-distribution-url：指定Gradle distribution的URL地址，这个参数会覆盖以上的两个参数，在公司内网使用时会经常用到</span><br><span class="line">    </span><br><span class="line">--gradle-distribution-sha256-sum：下载的Gradle distribution校验码，为了安全起见，建议设置。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定gradle distribution版本和类型</span></span><br><span class="line">xiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; gradle wrapper --gradle-version 5.3.1 --distribution-type all</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> 1s</span><br><span class="line">1 actionable task: 1 executed</span><br><span class="line"></span><br><span class="line">xiaobai:/Users/xiaobai/gradle_study/gradle_demo&gt; cat gradle/wrapper/gradle-wrapper.properties</span><br><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程地址的版本和类型和以上设置对应</span></span><br><span class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-5.3.1-all.zip</span><br><span class="line"></span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br></pre></td></tr></table></figure><p>PS:在实际工程中还有一种指定版本和类型的方式是在构建脚本中配置，只需要执行<code>gradle wrapper</code>就好</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">build.gradle</span><br><span class="line">task wrapper(<span class="string">type:</span> Wrapper)&#123;</span><br><span class="line">    gradleVersion = <span class="string">'5.3.1'</span></span><br><span class="line">    distributionType = <span class="string">'bin'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>简单体验了下Gradle，感受到了其灵活和高度可定制，可折腾性不错。</li><li>task和plugin是两个重要的东东。</li><li>Wrapper好用。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/13/5cb18aedb6b14.png&quot; alt=&quot;WX20190413-150809@2x.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上一篇文章中简单介绍了一下Gradle，既然从扩展性、灵活性、性能方面都这么出色，那这次就动手尝试看看如何使用Gradle来构建项目。&lt;br&gt;
    
    </summary>
    
      <category term="gradle" scheme="http://melody12ab.github.io/categories/gradle/"/>
    
    
      <category term="gradle" scheme="http://melody12ab.github.io/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Gradle系列(一)-Gradle介绍</title>
    <link href="http://melody12ab.github.io/2019/04/13/gradle-first-introduce/"/>
    <id>http://melody12ab.github.io/2019/04/13/gradle-first-introduce/</id>
    <published>2019-04-13T05:33:54.000Z</published>
    <updated>2019-04-13T17:29:50.506Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/04/13/5cb18aedb6b14.png" alt="WX20190413-150809@2x.png"></p><blockquote><p>前言：最近在学习Netty，其中看到不少牛牛们的项目工程都是使用gradle构建的，作为一个上（好）进（奇）的程序员，打开了Gradle的官网，了解了一番，这里做个记录。</p></blockquote><h3 id="Gradle官网（学习Gradle的不二之选）"><a href="#Gradle官网（学习Gradle的不二之选）" class="headerlink" title="Gradle官网（学习Gradle的不二之选）"></a>Gradle官网（学习Gradle的不二之选）</h3><p><a href="https://gradle.org/" target="_blank" rel="noopener">https://gradle.org/</a></p><a id="more"></a> <h3 id="Gradle简介"><a href="#Gradle简介" class="headerlink" title="Gradle简介"></a>Gradle简介</h3><p>Gradle是一个旨在提高开发者效率的构建工具。不管是移动APP还是微服务，不管是小的初创项目或者大型企业级项目，Gradle都可以帮我们更好更快的自动化的构建实现我们的软件项目。</p><blockquote><p>引自wikipedia：Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy（新版还可基于kotlin）的特定领域语言来声明项目设置，而不是传统的XML。</p></blockquote><h3 id="Gradle对比Maven"><a href="#Gradle对比Maven" class="headerlink" title="Gradle对比Maven"></a>Gradle对比Maven</h3><p><img src="https://gradle.org/images/gradle-vs-maven.png" alt="Gradle VS Maven"></p><h4 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h4><p>Gradle和Maven虽都提供了约定由于配置的机制，但是Maven提供的是一个非常严格，对用户定制不太友好甚至有时无法定制的系统，这也侧面展示了Maven的能力范围，只要你没有一些定制化的特殊需求，Maven基本可以满足大多数需要自动化构建的场景，在这一点上，Gradle就给予了用户更大的灵活度，同时还降低了复杂度。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p><img src="https://i.loli.net/2019/04/13/5cb1934e3f2d0.png" alt="WX20190413-154338@2x.png"><br>Maven和Gradle都使用了并行构建，并行依赖解析的方式。Gradle区别于Maven最大的地方在于其work avoidance and incrementality机制。最大的3个让Gradle构建更快的原因是：</p><ol><li>Incrementality：Gradle不会对Task的所有输入进行追踪构建，只会尽量处理被改变了的文件。</li><li>Build Cache：充分重用构建以前的构建结果，即便是其他Gradle版本或其他机器上构建出的结果。</li><li>Gradle Daemon：后台进程对构建信息进行持续追踪，keeps build information “hot” in memory。</li></ol><p>更多性能对比见<a href="https://gradle.org/gradle-vs-maven-performance/" target="_blank" rel="noopener">Gradle vs Maven: Performance Comparison</a></p><h4 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h4><p>Maven作为现在大多数项目默认使用的构建工具，得到了大多数IDE的支持。Gradle这方面还是快速的进步，比如现在Gradle还支持了基于Kotlin DSL进行构建逻辑的定义，使支持Kotlin的的IDE自然的友好支持了Kotlin。除了使用IDE，还有很多用户喜欢使用命令行进行构建，Gradle也提供了待自动提示的命令行工具<a href="https://github.com/gradle/gradle-completion" target="_blank" rel="noopener">gradle-completion</a>。</p><h4 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h4><p>Ant与Maven对于Gradle，前者编写容易，但功能有限，需要人工操作的过程也多；后者依托于庞大的依赖仓库，因此有着强大的外部依赖管理，但添加本地依赖并不方便，且项目不能灵活修改。而Gradle能很好地结合Ant与Maven各自的优点，可以随意的编写任务并组合成项目，直接利用Maven仓库，并且能很好的支持传递依赖和内部依赖。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/13/5cb18aedb6b14.png&quot; alt=&quot;WX20190413-150809@2x.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前言：最近在学习Netty，其中看到不少牛牛们的项目工程都是使用gradle构建的，作为一个上（好）进（奇）的程序员，打开了Gradle的官网，了解了一番，这里做个记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Gradle官网（学习Gradle的不二之选）&quot;&gt;&lt;a href=&quot;#Gradle官网（学习Gradle的不二之选）&quot; class=&quot;headerlink&quot; title=&quot;Gradle官网（学习Gradle的不二之选）&quot;&gt;&lt;/a&gt;Gradle官网（学习Gradle的不二之选）&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://gradle.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://gradle.org/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="gradle" scheme="http://melody12ab.github.io/categories/gradle/"/>
    
    
      <category term="gradle" scheme="http://melody12ab.github.io/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 数据预处理之One-Hot Encoding</title>
    <link href="http://melody12ab.github.io/2018/04/19/one-hot-encoding/"/>
    <id>http://melody12ab.github.io/2018/04/19/one-hot-encoding/</id>
    <published>2018-04-19T14:11:28.000Z</published>
    <updated>2019-04-10T15:48:11.643Z</updated>
    
    <content type="html"><![CDATA[<p>看到One-Hot-Encoding发现网上大多数说明都是来自于同一个例子，最后结果感觉出的好突兀，因此这里总结一下。</p><p>很多机器学习任务中，特征并不总是连续值，有可能是分类值。</p><a id="more"></a><p>考虑以下三个特征：</p><blockquote><p>[“male”, “female”]</p><p>[“from Europe”, “from US”, “from Asia”]</p><p>[“uses Firefox”, “uses Chrome”, “uses Safari”, “uses Internet Explorer”]</p></blockquote><p>如果将上述特征用数字表示，效率会高很多。例如：</p><blockquote><p>[“male”, “from US”, “uses Internet Explorer”] 表示为[0, 1, 3]</p><p>[“female”, “from Asia”, “uses Chrome”]表示为[1, 2, 1]</p></blockquote><p>但是，转化为数字表示后，上述数据不能直接用在我们的分类器中。因为，分类器往往默认数据数据是连续的，并且是有序的。但按上述表示的数字并不有序的，而是随机分配的。</p><h2 id="One-Hot-Encoding"><a href="#One-Hot-Encoding" class="headerlink" title="One-Hot Encoding"></a>One-Hot Encoding</h2><p>解决上述问题的一种方法是采用One-Hot Encoding。</p><p>独热编码，又称一位有效编码，其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都有它独立的寄存器位，并且在任意时候，其中只有一位有效。</p><p>例如：</p><blockquote><p>自然状态码为：000,001,010,011,100,101</p><p>独热编码为：000001,000010,000100,001000,010000,100000</p></blockquote><p>可以这样理解，对于每一个特征，如果它有m个可能值，那么经过独热编码后，就变成了m个二元特征。并且，这些特征互斥，每次只有一个激活。因此，数据会变成稀疏的。</p><p>这样做的好处主要有：</p><ol><li><p>解决了分类器不好处理属性数据的问题</p></li><li><p>在一定程度上也起到了扩充特征的作用</p></li></ol><p>基于python和Scikit-learn的一个简单例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">encoder = preprocessing.OneHotEncoder()</span><br><span class="line">encoder.fit([</span><br><span class="line">    [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">12</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">12</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line">])</span><br><span class="line">encoded_vector = encoder.transform([[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>]]).toarray()</span><br><span class="line">print(<span class="string">"\n Encoded vector ="</span>, encoded_vector)</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>Encoded vector = [[ 0.  0.  1.  0.  1.  0.  0.  0.  1.  1.  0.]]</p></blockquote><p>分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4个特征：</span><br><span class="line">第一个特征（即为第一列）为[0,1,2,1] ，其中三类特征值[0,1,2]，因此One-Hot Code可将[0,1,2]表示为:[100,010,001]</span><br><span class="line">同理第二个特征列可将两类特征值[2,3]表示为[10,01]</span><br><span class="line">第三个特征将4类特征值[1,2,4,5]表示为[1000,0100,0010,0001]</span><br><span class="line">第四个特征将2类特征值[3,12]表示为[10,01]</span><br><span class="line"></span><br><span class="line">因此最后可将[2,3,5,3]表示为[0,0,1,0,1,0,0,0,1,1,0]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到One-Hot-Encoding发现网上大多数说明都是来自于同一个例子，最后结果感觉出的好突兀，因此这里总结一下。&lt;/p&gt;
&lt;p&gt;很多机器学习任务中，特征并不总是连续值，有可能是分类值。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://melody12ab.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="one-hot" scheme="http://melody12ab.github.io/tags/one-hot/"/>
    
      <category term="machine learning" scheme="http://melody12ab.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>根据Servlet-API源码分析学习Servlet</title>
    <link href="http://melody12ab.github.io/2018/04/18/study-servlet-source/"/>
    <id>http://melody12ab.github.io/2018/04/18/study-servlet-source/</id>
    <published>2018-04-18T05:23:54.000Z</published>
    <updated>2019-04-10T15:48:25.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>介于Servlet是Java Web开发的基础，因此好好看了一下Servlet3.0.1的源码，于是有了这篇记录。<br><img src="http://upload-images.jianshu.io/upload_images/356003-58baa54b8e0aa008.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Servlet架构图"></p><blockquote><p>Servlet和JSP是众多java EE定义的技术当中的两种，其他还有JMS，EJB等等，运行JEE程序需要一个JEE容器，如GlassFish、JBOSS、WebLogic等，Servlet\JSP也可以部署在JEE容器中，不过用Servlet/JSP容器已经足够了，而且比JEE容器更加轻量化，Tomcat和Jetty不属于JEE容器，不能运行EJB或JMS。</p></blockquote><a id="more"></a><h2 id="Servlet-API概述"><a href="#Servlet-API概述" class="headerlink" title="Servlet API概述"></a>Servlet API概述</h2><p>首先，下载Servlet-api源码，可以使用IDE，maven等方式，本文使用maven下载，命令如下（或者自行搜索下载源码）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maven dependency:sources</span><br></pre></td></tr></table></figure><p>servlet API中有4个Java包，包括：</p><ul><li><p>javax.servlet    定义Servlet和Servlet容器之间的七月类和接口。</p></li><li><p>javax.servlet.http    定义HTTP Servlet与Serlvet容器之间的契约和接口</p></li><li><p>javax.servlet.annotation  包含对Servlet、Filter和Listener进行标注的注解。还为标注元件指定元数据。</p></li><li><p>javax.servlet.descriptor    包含为Web应用程序的配置星系提供编程式访问的类型。</p></li></ul><h3 id="javax-servlet包"><a href="#javax-servlet包" class="headerlink" title="javax.servlet包"></a>javax.servlet包</h3><p>不完整截图：</p><p><img src="http://upload-images.jianshu.io/upload_images/356003-d4d4306658e2e6b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="javax.servlet方法一览"></p><p>Servlet包中的主要成员：</p><p><img src="http://upload-images.jianshu.io/upload_images/356003-389e831617d5ca8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Servlet主要成员"></p><p>Servlet接口是核心接口，是所有Serlvet都必须直接或间接实现的一个接口，Servlet接口定义了Servlet与Servlet容器之间的约定，总的来说就是Servlet容器会把Servlet类加载到内存中，并在Servlet实例中调用特定方法，在一个应用程序中，每个Servlet类型只能有一个实例。当用户的请求引发service方法，并给这个方法传入一个ServletRequest实例和一个ServletResponse实例。ServletRequest封装当前的HTTP请求，让开发者不必去解析和操作原始的HTTP数据，同理，ServletResponse表示当前用户的HTTP响应，它的作用是使得将响应回传给用户更容易。Servlet容器还为每个应用程序创建一个ServletContext实例。这个对象封装context（应用程序）的环境细节，而每个context只有一个ServletContext。每个Servlet实例还有一个封装Servlet配置信息的ServletConfig。</p><h3 id="Servlet-1"><a href="#Servlet-1" class="headerlink" title="Servlet"></a>Servlet</h3><p>下面先看看Servlet接口，（如果别人问你什么是Servlet，你可以告诉他，就是一个java接口，分分钟定义出来给你看，不过人们常说的Servlet应该是指任何实现了Servlet接口的类）看源码发现有234行（3.0.1版），仔细一看也就5个抽象方法，其他的全是注释，所以兄弟们，看源码不要虚，这就是传说中的和Servlet容器之间的约定（有没有很熟悉的感觉）：</p><p><img src="http://upload-images.jianshu.io/upload_images/356003-dff109fe771f3fc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Servlet接口"></p><ul><li><p>init 第一次请求我们编写的Serlvet时，Servlet容器调用此方法，后续不在调用，可以利用这个方法做一些初始化的工作。在调用这个方法时，Servlet容器会传递一个ServletConfig。一般会将这个ServletConfig赋给一个类级变量，以方便其他方法也可以使用这个对象。</p></li><li><p>service 每次用户请求service时，servlet容器都会调用这个方法，我们对请求的处理就是在这里完成的。</p></li><li><p>destroy 要销毁Servlet时，Servlet容器就会调用这个方法，它通常发生在卸载应用程序，或者关闭Servlet容器的时候，这里一般我们会写一些资源清理相关的代码。</p></li></ul><p>Servlet中另外另个费生命周期的方法：getServletInfo和getServletConfig</p><ul><li><p>getServletInfo 就是字面意思，返回Servlet的描述</p></li><li><p>getServletConfig 这个方法返回由Servlet容器传给init方法的ServletConfig，上面说了，一般在init方法中将ServletConfig赋给一个类级变量，免得本方法返回null。</p></li></ul><blockquote><p>PS:由于Servlet不是线程安全的，一个应用程序中所有的用户公用一个Servlet实例，因此不建议使用类级别的变量（只使用局部变量最好），除非是只读的或者java.utilconcurrent.atomic包中的成员。</p></blockquote><h3 id="Servlet基础应用程序"><a href="#Servlet基础应用程序" class="headerlink" title="Servlet基础应用程序"></a>Servlet基础应用程序</h3><p>现在来写一个Servlet应用程序，写起来很简单，只要创建一个目录，并将Servlet类放在指定目录中就可以了，同时，如果要运行这个应用程序，你还需要安装一个Servlet容器，如Tomcat或者Jetty（安装方法自行搜索）。</p><h4 id="编写Servlet应用"><a href="#编写Servlet应用" class="headerlink" title="编写Servlet应用"></a>编写Servlet应用</h4><p><img src="http://upload-images.jianshu.io/upload_images/356003-10e0cf754d6ab495.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Servlet应用目录结构"></p><p>以上为Servlet的目录结构，要编译servlet，类路径中还要有servlet API，tomcat容器中已经自带了servlet-api.jar。另外珍爱生命，还是用IDE来创建吧，博主试过，自己去一步一步创建配置虽说也可以，但是确实会花费不少时间，如果你就是要自己一步一步创建，觉得这样能学到更多东西，我只能说加油骚年！</p><p>应用程序中一般会有JSP、HTML、图像等其他资源，这些都应该放在应用程序的目录下面，并且经常放在子目录下，如上图，html放在html文件下，jsp放在jsp目录下。放在应用程序目录下的任何资源，用户可以通过资源的URL直接访问（放在应用程序目录下当然要可以访问了），如果希望某个资源可以被Servlet访问，但不能被用户访问，那就应该放在WEB-INF目录下（是不是找到该目录的作用了）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//name可选，提供servlet名，关键urlPatterns指定匹配当前servlet的模式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(name=<span class="string">"/FirstServlet"</span>,urlPatterns=&#123; <span class="string">"/myapp"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ServletConfig config;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将config给类变量，扩大使用范围</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.config=config;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> config;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"My Servlet"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">String servletName=config.getServletName();</span><br><span class="line"></span><br><span class="line">response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">PrintWriter pw=response.getWriter();</span><br><span class="line"></span><br><span class="line">pw.write(<span class="string">"hello from "</span>+servletName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序部署完成，启动Servlet容器，就可以通过url在浏览器中访问了：</p><p>通过访问  <a href="http://localhost:8080/App01/FirstServlet" target="_blank" rel="noopener">http://localhost:8080/App01/FirstServlet</a></p><p><img src="http://upload-images.jianshu.io/upload_images/356003-3f3e129d51d92cfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><h3 id="ServletRequest-amp-ServletResponse"><a href="#ServletRequest-amp-ServletResponse" class="headerlink" title="ServletRequest &amp; ServletResponse"></a>ServletRequest &amp; ServletResponse</h3><p>对于每一个HTTP请求，servlet容器会创建一个封装了HTTP请求的ServletRequest实例传递给servlet的service方法，ServletResponse则表示一个Servlet响应，其影藏了将响应发给浏览器的复杂性。通过ServletRequest的方法你可以获取一些请求相关的参数，而ServletResponse则可以将设置一些返回参数信息，并且设置返回内容。返回内容之前一般会调用setContentType方法设置响应的内容类型，如果没有设置，大多数浏览器会默认以html的形式响应，不过为了避免出问题，我们一般都设置该项。</p><p>值得注意的是ServletResponse中定义的getWriter方法，它返回可以将文本传给客户端的java.io.PrintWriter。在默认的情况下，PrintWriter对象使用ISO-8859-1编码，这有可能引起乱码。</p><p>以下为ServletRequest和ServletResponse的大部分方法：</p><p><img src="http://upload-images.jianshu.io/upload_images/356003-a38efde98fe9cea7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ServletRequest"></p><p><img src="http://upload-images.jianshu.io/upload_images/356003-5e37d367f8dade03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ServletResponse"></p><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><p>ServletConfig封装可以通过@WebServlet或者web.xml传给一个Servlet的配置信息，以这种方式传递的每一条信息都称做初始化信息，初始化信息就是一个个K-V键值对。为了从一个Servlet内部获取某个初始参数的值，init方法中调用ServletConfig的getinitParameter方法或getinitParameterNames方法获取，除此之外，还可以通过getServletContext获取ServletContext对象。方法签名：</p><p><img src="http://upload-images.jianshu.io/upload_images/356003-e5cf0944e8282e38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ServletConfig"></p><p>通过WebServlet传递配置信息示例：</p><p><img src="http://upload-images.jianshu.io/upload_images/356003-7b94c480efae89c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WebServlet初始化参数"></p><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>ServletContext是代表了Servlet应用程序。每个Web应用程序只有一个context。在分布式环境中，一个应用程序同时部署到多个容器中，并且每台Java虚拟机都有一个ServletContext对象。有了ServletContext对象后，就可以共享能通过应用程序的所有资源访问的信息，促进Web对象的动态注册，共享的信息通过一个内部Map中的对象保存在ServiceContext中来实现。保存在ServletContext中的对象称作属性。操作属性的方法：</p><p><img src="http://upload-images.jianshu.io/upload_images/356003-2a888d782664b6ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ServletContext"></p><h3 id="GenericServlet"><a href="#GenericServlet" class="headerlink" title="GenericServlet"></a>GenericServlet</h3><p>前面编写的Servlet应用中通过实现Servlet接口来编写Servlet，但是我们每次都必须为Servlet中的所有方法都提供实现，还需要将ServletConfig对象保存到一个类级别的变量中，GenericServlet抽象类就是为了为我们省略一些模板代码，实现了Servlet和ServletConfig，完成了一下几个工作：</p><ul><li>将init方法中的ServletConfig赋给一个类级变量，使的可以通过getServletConfig来获取。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.config = config;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>同时为避免覆盖init方法后在子类中必须调用super.init(servletConfig)，GenericServlet还提供了一个不带参数的init方法，当ServletConfig赋值完成就会被第带参数的init方法调用。这样就可以通过覆盖不带参数的init方法编写初始化代码，而ServletConfig实例依然得以保存（这难道不是适配器模式吗？）</p><ul><li><p>为Servlet接口中的所有方法提供默认实现。</p></li><li><p>提供方法来包装ServletConfig中的方法。</p></li></ul><p>用GenericServlet实现Servlet应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.GenericServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebInitParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(name=<span class="string">"SecondServlet"</span>,</span><br><span class="line"></span><br><span class="line">     urlPatterns=&#123;<span class="string">"/generic"</span>&#125;,</span><br><span class="line"></span><br><span class="line">     initParams=&#123;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@WebInitParam</span>(name=<span class="string">"user"</span>,value=<span class="string">"xiaobai"</span>),</span><br><span class="line"></span><br><span class="line">         <span class="meta">@WebInitParam</span>(name=<span class="string">"email"</span>,value=<span class="string">"xiaobai@example.com"</span>)</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">         ServletConfig config=getServletConfig();</span><br><span class="line"></span><br><span class="line">         String user=config.getInitParameter(<span class="string">"user"</span>);</span><br><span class="line"></span><br><span class="line">         String email=config.getInitParameter(<span class="string">"email"</span>);</span><br><span class="line"></span><br><span class="line">         response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">         PrintWriter pw=response.getWriter();</span><br><span class="line"></span><br><span class="line">         pw.write(<span class="string">"User:"</span>+user+<span class="string">"&lt;br&gt;email:"</span>+email);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HTTPServlet"><a href="#HTTPServlet" class="headerlink" title="HTTPServlet"></a>HTTPServlet</h3><p>在编写Servlet应用程序时，大多数都要用到HTTP，也就是说可以利用HTTP提供的特性，javax.servlet.http包含了编写Servlet应用程序的类和接口，其中很多覆盖了javax.servlet中的类型，我们自己在编写应用时大多时候也是继承的HttpServlet，以下为其中的重要成员:</p><p><img src="http://upload-images.jianshu.io/upload_images/356003-dffa75f6ab2e7ba1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HttpServelt主要成员"></p><p>从上图看，HttpServlet继承了GenericServlet，HttpServletRequest/Response继承了覆盖了ServletRequest/Response，成为了新的Servlet请求和响应的代表。在HttpServlet中覆盖了GenericServlet的service方法，并用新的Servlet请求和响应代表作为参数添加了一个service方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//覆盖GenereicServlet中的service</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">           HttpServletRequest  request;</span><br><span class="line">           HttpServletResponse response;</span><br><span class="line">           <span class="keyword">if</span> (!(req <span class="keyword">instanceof</span> HttpServletRequest &amp;&amp;</span><br><span class="line">                   res <span class="keyword">instanceof</span> HttpServletResponse)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"non-HTTP request or response"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           request = (HttpServletRequest) req;</span><br><span class="line">           response = (HttpServletResponse) res;</span><br><span class="line">           service(request, response);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新service方法签名</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br></pre></td></tr></table></figure><p>原始的service方法将请求和响应进行向下转换，分别为HttpServletRequest和HttpServletResponse，并调用新的service方法。看了下2.5版本中的实现，发现没有加以上代码是中的instanceof判断，恩，看来2.5中直接向下转型确实暴力了点，考虑容器不一定总是把请求当做HTTP请求，这样做看起来稳妥了些。新的service方法会查寻HTTP请求的方法从而调用do{Method}来处理请求。</p><p>总之HttpServlet中有两项特性是GenericServlet中没有的：</p><ul><li><p>不覆盖service方法，而是覆盖doGet、doPost等。</p></li><li><p>用HttpServletRequest\Response 替代ServletRequest\Response</p></li></ul><p>HttpServletRequest，HttpServletResponse由于带有了HTTP的特性，因此除了ServletRequest，ServletResponse中的方法之外还增加了几个可以获取HTTP特性信息的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取context的请求URI部分</span></span><br><span class="line"></span><br><span class="line">java.lang.<span class="function">String <span class="title">getContextPath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//获取Cookie对象数组</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Cookie [] <span class="title">getCookies</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回指定HTTP标头的值</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">java.lang.String <span class="title">getHeader</span><span class="params">(java.lang.String name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回发出这条请求的HTTP方法的名称</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">java.lang.String <span class="title">getMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回请求URL中的查询字符串</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">java.lang.String <span class="title">getQueryString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//获取session对象，没找到就新创建</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">HttpSession <span class="title">getSession</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回与这个请求相关的session对象，如果没有，并且create参数为true，创建新的session对象</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//响应对象添加cookie</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addCookie</span><span class="params">(Cookie cookie)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//添加标头</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addheader</span><span class="params">(String name,String value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//重定向</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendRedirect</span><span class="params">(String location)</span></span></span><br></pre></td></tr></table></figure><h3 id="使用web-xml配置Servlet应用"><a href="#使用web-xml配置Servlet应用" class="headerlink" title="使用web.xml配置Servlet应用"></a>使用web.xml配置Servlet应用</h3><p>在Servlet3.x中可以使用@WebServlet来部署应用，可以不必在WEB-INF目录下放一个web.xml配置文件，当然也可以同时使用，前者优先级更高，这是annotation为我们带来的好处，介于使用web.xml来配置Servlet也有其有点，就简单介绍下，使用web.xml配置优点：</p><ul><li><p>不用更改代码，也就意味着不需要重新编译</p></li><li><p>可包含@WebServlet中没有的元素，如load-on-startup元素，init方法比较费时间这个就很有帮助了。</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SimpleServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>app01.SimpleServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SimpleServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/simple<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><p>现在再来看下我们我们通常写的Servlet，看完上文的客官，看到下面Servlet是不是感觉自己看到了更多的东西呢？反正我是看到了。讲真，如果想要缕下Servlet的话，真的可以试一试下载Servlet-api的源码看看，结合本文，或许风味更佳哦！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/normal"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">response.getWriter().append(<span class="string">"Served at: "</span>).append(request.getContextPath());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">doGet(request, response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Servlet技术是Java EE技术的重要组成，Servlet容器中运行的所有Servlet，以及容器与Servlet之间的约定，都采用了javax.servlet.Servlet接口的形式。javax.servlet包也提供了实现Servlet接口的GenericServlet抽象类。这是一个比较方便的类，可以通过扩展它来创建Servlet。但是大多数的现代Servlet都在HTTP环境中处理请求，因此提供了javax.servlet.http.HttpServlet来继承GenericServlet并且加入HTTP特性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Servlet&quot;&gt;&lt;a href=&quot;#Servlet&quot; class=&quot;headerlink&quot; title=&quot;Servlet&quot;&gt;&lt;/a&gt;Servlet&lt;/h1&gt;&lt;p&gt;介于Servlet是Java Web开发的基础，因此好好看了一下Servlet3.0.1的源码，于是有了这篇记录。&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/356003-58baa54b8e0aa008.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Servlet架构图&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Servlet和JSP是众多java EE定义的技术当中的两种，其他还有JMS，EJB等等，运行JEE程序需要一个JEE容器，如GlassFish、JBOSS、WebLogic等，Servlet\JSP也可以部署在JEE容器中，不过用Servlet/JSP容器已经足够了，而且比JEE容器更加轻量化，Tomcat和Jetty不属于JEE容器，不能运行EJB或JMS。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="servlet" scheme="http://melody12ab.github.io/categories/servlet/"/>
    
    
      <category term="servlet" scheme="http://melody12ab.github.io/tags/servlet/"/>
    
      <category term="java" scheme="http://melody12ab.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>开篇</title>
    <link href="http://melody12ab.github.io/2018/01/01/hello-world/"/>
    <id>http://melody12ab.github.io/2018/01/01/hello-world/</id>
    <published>2017-12-31T16:00:00.000Z</published>
    <updated>2019-04-10T15:43:53.401Z</updated>
    
    <content type="html"><![CDATA[<p>一直想好好有个写博客的地方，现在算是正式入坑，好好加油吧，少年！！！</p><p><img src="/images/ydcb.jpeg" alt="Castle"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直想好好有个写博客的地方，现在算是正式入坑，好好加油吧，少年！！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/ydcb.jpeg&quot; alt=&quot;Castle&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
